---
title: 面经
tag:
  - 面经
category: 
  - 面经
#cover: /img/qq/2aa699e53a2f27bb64fce4399c591742.jpg
#permalink: /gallery/girl
---

# 面经

# 腾讯云智后端暑期实习一面

## redis数据结构

1. 5种基本数据类型：String（字符串）、List(列表)、Set（集合）、Hash（散列）、Zset（有序集合）
2. 3种特殊数据类型：HyperLogLog(基数统计)、Bitmap(位图)、Geospatial（地理位置）



鉴于 HyperLogLog 不保存数据内容的特性，所以，它只适用于一些特定的场景。我这里给出一个最常遇到的场景需要：计算日活、7日活、月活数据。





比如我们有一个App，需要统计2021年每个用户登录的情况，针对这个需求，我们以用户id+2021作为key，将用户上线那天对应的offset设置为1，这样就可以统计每个用户在本年度登录的情况，使用bitcount可以统计登录天数。

举个例子，今天是2021年第100天，而`user_id:10001`在今天阅览过网站，那么执行命令 `SETBIT 2021:user_id:10001 100 1` ；如果明天 该用户也登录的App，那么执行命令 `SETBIT 2021:user_id:10001 101 1` ，以此类推。

最后使用 `BITCOUNT 2021:user_id:10001`，就可以统计该用户本年度登录App的次数了

通过上例我们可以看出，使用Bitmap来统计二值数据非常节省内存，一个用户一年只需要占用 365个比特，10年也只需要 365*10/8=456个字节。

## redis如何查看所有的键，有什么要注意的地方？

1. keys * 或者 scan 游标值

2. 使用keys时，会影响redis性能，当key很多时，需要检索出所有的key；而使用scan时，可以限制查找key的数量和条件。

3. ## redis持久化机制

   1. RDB：快照模式，将redis内存数据保存到磁盘里面。
   2. AOF：日志模式，将redis执行语句以日志文件的形式记录下来。

4. ## redis缓存雪崩解决方案

   1. 什么是缓存雪崩：当大量的缓存key同时过期，一时间大量的请求涌入，导致数据库压力过大。
   2. 如何解决
      1. 给key设置不同的过期时间
      2. 开启redis集群
      3. 多级缓存
      4. 热点数据永不过期
      5. 限流和降级



## mysql的聚簇索引和非聚簇索引

1. 聚簇索引：非叶子节点存放索引，叶子节点存放数据。
   1. ![image-20240409124856880](E:\星球项目\笔记\assets\image-20240409124856880.png)
2. 非聚簇索引：叶子节点存放的是主键，根据主键再回表查询。不一定要回表查询，当查询的数据刚好是主键时，则不需要回表查询。
3. ![image-20240410082203994](./assets/image-20240410082203994.png)

## 慢SQL的排查处理优化

1. 使用MySQL的explain命令查询的执行计划，索引使用情况
2. 检查key和key_len字段，检查查询是否有效利用索引。注意索引覆盖，即索引包含了查询的所需的索引列，避免回表。
3. 避免使用select * ；避免在索引字段使用函数，会导致索引失效；避免使用or连接条件，替换为union；

![image-20240410083405391](./assets/image-20240410083405391.png)

## Java源文件的编译运行过程

1. idea编译器将.java文件编译成.class文件
2. jvm将.class字节码文件转换为机器码给操作系统执行
3. ![image-20240410084136796](./assets/image-20240410084136796.png)



## GC算法有哪些

1. GC是Garbage Collention，是垃圾回收机制。
2. **标记-清除算法（Mark and Sweep）**：这是最基本的垃圾收集算法之一。它分为两个阶段：标记阶段和清除阶段。首先，标记阶段会遍历程序中的所有对象，并标记那些仍然是活跃的对象。然后，在清除阶段，未被标记的对象被视为垃圾，将其回收释放。缺点是会产生内存碎片，影响内存的连续分配。
3. **复制算法（Copying）**：复制算法将内存分为两块，每次只使用其中一块。当一块内存被占满时，将其中的存活对象复制到另一块内存中，然后清空原来的内存块。这样可以保证内存空间始终是连续的，但是需要额外的内存空间来存放复制后的对象。
4. **标记-整理算法（Mark and Compact）**：这种算法结合了标记-清除和复制算法的优点。首先，标记阶段会标记活跃对象，然后将这些对象向一端移动，然后清除所有非活跃对象，使得内存空间变得连续。这样既避免了内存碎片的问题，又减少了复制算法中需要的额外空间。
5. **分代算法（Generational）**：这是针对对象生命周期不同的情况而提出的一种算法。根据对象的年龄将内存划分为几代，一般是新生代、老年代和永久代。新创建的对象会被分配到新生代，而经过多次垃圾回收仍然存活的对象会被晋升到老年代。因为大部分对象的生命周期较短，所以新生代的垃圾收集会更频繁，而老年代的垃圾收集则相对较少，这样可以提高垃圾回收的效率。
6. **增量式垃圾收集算法（Incremental）**：在应用程序运行的同时，逐步进行垃圾收集，而不是等到所有活跃对象都被标记后再进行清理。这样可以减少单次垃圾回收的停顿时间，提高了系统的响应性。

## Java多线程的线程安全处理

1. **使用同步方法（Synchronized Methods）**：通过在方法声明中添加`synchronized`关键字来确保方法的原子性，即在同一时刻只有一个线程能够进入该方法。这样可以避免多个线程同时访问共享资源造成的问题。

   ```
   javaCopy codepublic synchronized void synchronizedMethod() {
       // 同步代码块
   }
   ```

2. **使用同步代码块（Synchronized Blocks）**：使用`synchronized`关键字来创建同步代码块，将需要保护的临界区域包含在其中，以确保在同一时刻只有一个线程能够执行这段代码。

   ```
   javaCopy codesynchronized (obj) {
       // 同步代码块
   }
   ```

3. **使用ReentrantLock**：`java.util.concurrent.locks.ReentrantLock`是Java提供的显示锁机制，它提供了更灵活的同步控制，例如可中断锁、定时锁等。使用`lock()`方法来获取锁，`unlock()`方法来释放锁。

   ```java
   private final ReentrantLock lock = new ReentrantLock();
   
   public void someMethod() {
       lock.lock();
       try {
           // 同步代码块
       } finally {
           lock.unlock();
       }
   }
   ```

4. **使用volatile关键字**：`volatile`关键字用于标记变量，确保多个线程对该变量的读写操作都是可见的。虽然`volatile`可以保证可见性，但是不能保证原子性。

   ```
   private volatile int count;
   ```

5. **使用线程安全的集合类**：Java提供了一些线程安全的集合类，如`java.util.concurrent.ConcurrentHashMap`、`java.util.concurrent.CopyOnWriteArrayList`等，它们在并发环境中提供了更好的性能和线程安全性。

6. **使用原子类（Atomic Classes）**：Java提供了一系列原子类，如`AtomicInteger`、`AtomicLong`等，它们提供了一种在并发环境中进行原子操作的方法，从而避免了线程安全问题。

   ```
   private AtomicInteger count = new AtomicInteger();
   
   public void increment() {
       count.incrementAndGet();
   }
   ```

## 面向对象特性

1. **封装（Encapsulation）**：封装是将数据和操作数据的方法封装在一起的机制，通过访问修饰符（如`public`、`private`、`protected`等）来控制对数据的访问。封装可以隐藏对象的内部细节，只暴露出必要的接口，从而提高了代码的安全性和可维护性。
2. **继承（Inheritance）**：继承是一种代码重用的机制，它允许一个类（子类）继承另一个类（父类）的属性和方法。子类可以使用父类的属性和方法，并且可以通过扩展或重写来添加新的功能或修改现有功能。继承可以提高代码的可复用性和可扩展性。
3. **多态（Polymorphism）**：多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。多态是指同一个方法在不同的对象上具有不同的行为。多态通过方法的重载（Overloading）和方法的重写（Override）来实现。方法的重载是在同一个类中定义多个同名方法但参数列表不同，而方法的重写是子类重写父类的方法以提供特定实现。多态可以提高代码的灵活性和可扩展性。

## 讲一下设计模式，责任链的使用场景

1. 责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许多个对象（处理器）依次处理请求，直到其中一个对象能够处理该请求为止。在责任链模式中，每个处理器都持有对下一个处理器的引用，形成一个链条。请求沿着这个链条依次传递，直到有一个处理器处理该请求为止。

   责任链模式通常包含以下角色：

   1. **Handler（处理器）**：定义了一个处理请求的接口，通常包含一个处理方法。该接口可以是一个抽象类或接口，具体的处理器实现该接口。处理器通常会保存对下一个处理器的引用，并在处理方法中决定是否继续将请求传递给下一个处理器。
   2. **ConcreteHandler（具体处理器）**：具体处理器是实现了处理请求接口的具体类，负责处理具体的请求。如果能够处理请求，则处理该请求并结束；否则，将请求传递给下一个处理器。

   使用责任链模式的主要优点包括：

   - **解耦责任处理逻辑**：将责任链中的各个处理器解耦，每个处理器只需要关注自己负责处理的部分，从而提高了代码的可维护性和可扩展性。
   - **灵活性**：可以根据需要动态地调整责任链中处理器的顺序或添加新的处理器，而不需要修改现有的代码。
   - **单一职责原则**：每个具体处理器只负责处理特定类型的请求，符合单一职责原则，使得代码更加清晰和易于理解。

   责任链模式在实际应用中经常用于以下场景：

   - **权限控制**：在权限控制系统中，可以使用责任链模式实现不同权限级别的授权逻辑，每个节点负责判断请求是否满足自身权限要求，如果不满足则拒绝或者传递给下一个节点进行进一步处理。
   - **事件处理**：在事件驱动系统中，可以使用责任链模式处理事件。每个节点可以处理特定类型的事件，如果当前节点无法处理，则将事件传递给下一个节点处理，直到有节点处理或者事件被丢弃。
   - **日志记录**：在日志系统中，可以使用责任链模式实现日志记录器链，每个日志记录器负责记录特定级别的日志，如果当前记录器无法处理，则将日志传递给下一个记录器进行处理。
   - **异常处理**：在系统中可能存在多种异常情况，可以使用责任链模式处理异常。每个节点负责处理特定类型的异常，如果当前节点无法处理，则将异常传递给下一个节点进行处理。

## 软件设计原则，软件开发模型

1. 软件设计原则（Software Design Principles）是在软件开发过程中指导设计的基本准则或规范，它们帮助开发者设计出更加可维护、可扩展和易于理解的软件系统。常见的软件设计原则包括：
   1. **单一职责原则（Single Responsibility Principle，SRP）**：一个类应该只有一个引起变化的原因，即一个类应该只有一个责任。这个原则鼓励将一个类拆分成多个单一功能的类，以减少类的复杂性和耦合性。
   2. **开放-封闭原则（Open-Closed Principle，OCP）**：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着应该通过扩展现有的代码来实现新的功能，而不是修改现有的代码。
   3. **里氏替换原则（Liskov Substitution Principle，LSP）**：子类应该能够替换其基类而不影响程序的正确性。换句话说，子类型（子类或派生类）必须能够完全替代其基类型（父类或基类）。
   4. **依赖倒置原则（Dependency Inversion Principle，DIP）**：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
   5. **接口隔离原则（Interface Segregation Principle，ISP）**：客户端不应该强制依赖于它们不需要的接口。应该将大型接口拆分成更小的和更具体的接口，以确保客户端只需了解其需要的方法。
   6. **最少知识原则（Least Knowledge Principle，LoKP）**：一个类应该知道最少关于其他类的信息。换句话说，一个类应该只和它的朋友交谈，而不是和陌生人交谈。
2. 软件开发模型（Software Development Models）是一种软件开发过程的抽象描述，描述了软件开发过程中不同阶段的活动、任务、文档和交付物。常见的软件开发模型包括：
   1. **瀑布模型（Waterfall Model）**：瀑布模型是一种线性的软件开发过程，将开发过程分为需求分析、设计、实现、测试和维护等阶段，每个阶段依次执行。这种模型适用于需求稳定、开发过程清晰的项目。
   2. **迭代模型（Iterative Model）**：迭代模型将软件开发过程分为多个迭代周期，每个迭代周期包含需求分析、设计、实现、测试和部署等阶段。每个迭代周期都会交付一部分功能，并根据反馈进行调整。
   3. **增量模型（Incremental Model）**：增量模型将软件开发过程分为多个增量，每个增量都会增加一部分功能。每个增量都是独立的开发周期，包含需求分析、设计、实现、测试和部署等阶段。
   4. **螺旋模型（Spiral Model）**：螺旋模型将软件开发过程分为多个循环，每个循环包含风险分析、计划、执行和评审等阶段。每个循环都会逐步增加功能，并根据风险进行调整。
   5. **敏捷开发模型（Agile Model）**：敏捷开发是一种基于迭代和增量的软件开发方法，强调团队合作、快速交付和对变化的灵活响应。敏捷开发包括多种方法论，如Scrum、Kanban、XP等。

## TCP四次挥手，滑动窗口

1. ### TCP四次握手（Four-way Handshake）：

   1. **客户端发送连接请求（SYN）**：客户端发送一个带有SYN（同步序列编号）标志的数据包给服务器，请求建立连接。此时客户端进入SYN_SENT状态。
   2. **服务器响应确认连接请求（SYN-ACK）**：服务器收到客户端的SYN包后，如果同意建立连接，则会发送一个带有SYN和ACK（确认）标志的数据包给客户端以确认连接请求。此时服务器进入SYN_RECV状态。
   3. **客户端确认连接（ACK）**：客户端收到服务器的SYN-ACK包后，会发送一个带有ACK标志的数据包给服务器，确认收到服务器的确认请求。此时客户端和服务器都进入已建立连接的状态。
   4. **服务器确认连接（ACK）**：服务器收到客户端的ACK包后，连接建立完成，双方都可以开始进行数据传输。此时服务器进入已建立连接的状态。

2. ### TCP滑动窗口（Sliding Window）：

   滑动窗口是一种流量控制的机制，用于调节发送方和接收方之间的数据流量，以确保发送方不会发送过多的数据导致接收方无法处理。滑动窗口的大小由接收方和发送方协商确定。

   - **接收窗口（Receiver Window）**：接收方通过告知发送方其可接收的数据量来设置接收窗口的大小。发送方不能发送超过接收窗口大小的数据，以避免数据丢失或溢出。
   - **发送窗口（Sender Window）**：发送方通过告知接收方其可以发送的数据量来设置发送窗口的大小。发送方只能发送不超过发送窗口大小的数据，以避免发送过多数据导致网络拥塞。

   滑动窗口的机制允许发送方和接收方在数据传输过程中动态调整窗口大小，以适应网络的变化和处理能力的差异，从而实现更加高效和可靠的数据传输。

## HTTP报文格式，基于TCP还是UDP

HTTP（Hypertext Transfer Protocol）是一种应用层协议，用于在客户端和服务器之间传输超文本文档。HTTP报文是在TCP（Transmission Control Protocol）或UDP（User Datagram Protocol）之上传输的，但通常情况下，HTTP协议使用TCP作为传输层协议，因为TCP提供了可靠的数据传输和错误恢复机制，而UDP则不提供。

HTTP报文由两部分组成：请求报文和响应报文。

### HTTP请求报文格式：

```
<method> <request-target> <HTTP-version>
<headers>
<blank line>
[<request-body>]
```

- `<method>`：请求方法，如GET、POST、PUT等。
- `<request-target>`：请求目标，即请求的URL。
- `<HTTP-version>`：HTTP协议版本，如HTTP/1.1。
- `<headers>`：请求头部，包含请求的一些元数据，如Host、User-Agent、Content-Type等。
- `<blank line>`：空行，用于分隔头部和请求体。
- `[<request-body>]`：可选的请求体，包含请求的数据，如表单数据或JSON数据等。

### HTTP响应报文格式：

```
<HTTP-version> <status-code> <reason-phrase>
<headers>
<blank line>
[<response-body>]
```

- `<HTTP-version>`：HTTP协议版本，如HTTP/1.1。
- `<status-code>`：状态码，表示服务器对请求的处理结果，如200表示成功，404表示未找到等。
- `<reason-phrase>`：状态码的原因短语，如OK、Not Found等。
- `<headers>`：响应头部，包含响应的一些元数据，如Content-Type、Content-Length等。
- `<blank line>`：空行，用于分隔头部和响应体。
- `[<response-body>]`：可选的响应体，包含响应的数据，如HTML文档、JSON数据等。

总的来说，HTTP报文是基于TCP协议传输的，TCP提供了可靠的数据传输和错误恢复机制，使得HTTP能够在不可靠的网络环境下进行可靠的通信。

## 网络IO模型

网络 I/O 模型是描述应用程序与网络之间数据传输的方式和机制。主要的网络 I/O 模型包括阻塞 I/O 模型、非阻塞 I/O 模型、I/O 复用模型、事件驱动模型和异步 I/O 模型。

1. **阻塞 I/O 模型**：
   - 应用程序发起 I/O 操作后会阻塞（即线程挂起），直到操作完成。
   - 缺点是在进行 I/O 操作时，无法进行其他任务，因此效率较低。
2. **非阻塞 I/O 模型**：
   - 应用程序发起 I/O 操作后，不会阻塞，可以继续进行其他任务。
   - 但需要不断轮询 I/O 状态，判断是否完成，这会消耗大量 CPU 资源。
3. **I/O 复用模型**：
   - 使用单个线程同时处理多个 I/O 操作，通过 select、poll 或 epoll 等系统调用来监听多个文件描述符的状态。
   - 当某个文件描述符就绪时，再进行读写操作。
   - 可以提高并发性和效率，但仍然需要轮询，效率不高。
4. **事件驱动模型**：
   - 通过事件循环机制，将事件驱动地分发给事件处理器进行处理。
   - 典型的事件驱动框架包括 Reactor 模式和 Proactor 模式。
5. **异步 I/O 模型**：
   - 应用程序发起 I/O 操作后立即返回，无需等待操作完成。
   - 当操作完成时，操作系统会通知应用程序，应用程序再进行后续处理。
   - 可以实现高并发、高性能的网络编程，但需要操作系统和硬件的支持。

## 输入url流程，关于域名解析缓存的问题

输入 URL 的流程通常包括以下几个步骤：

1. 在浏览器中输入指定网页的 URL。

2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。

3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。

4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。

5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。

6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。

7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。

   ------

   著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/cs-basics/network/other-network-questions.html

关于域名解析缓存的问题，DNS 解析结果会被缓存到本地的 DNS 缓存中，以提高域名解析的速度和效率。缓存时间由 DNS 服务器返回的 TTL（Time To Live）字段决定，表示该解析结果在缓存中的有效时间。一般来说，TTL 时间较短的解析结果会被频繁更新，而 TTL 时间较长的解析结果则会被缓存更长时间。

当需要解析一个域名时，系统会先检查本地的 DNS 缓存，如果缓存中存在有效的解析结果，则直接使用缓存的结果，不需要向 DNS 服务器发起新的解析请求。这样可以减少对 DNS 服务器的负载，并加快域名解析的速度。

## Linux常用命令，TCP连接状态查看，文件大小等等

1. **查看 TCP 连接状态**：

   - 使用 

     ```
     netstat
     ```

      命令查看当前所有的网络连接状态：

     ```
     netstat -tuln
     ```

   - 使用 

     ```
     ss
     ```

      命令也可以查看网络连接状态：

     ```
     ss -tuln
     ```

2. **查看文件大小**：

   - 使用 

     ```
     ls
     ```

      命令查看文件的大小：

     ```
     ls -l <filename>
     ```

   - 使用 

     ```
     du
     ```

      命令查看文件或目录的大小：

     ```
     du -h <filename>
     ```

3. **查看进程信息**：

   - 使用 

     ```
     ps
     ```

      命令查看当前系统中的进程信息：

     ```
     ps aux
     ```

   - 使用 

     ```
     top
     ```

      命令实时查看系统的进程和资源占用情况：

     ```
     top
     ```

4. **查看系统信息**：

   - 使用 

     ```
     uname
     ```

      命令查看系统信息，如操作系统类型、内核版本等：

     ```
     uname -a
     ```

   - 使用 

     ```
     df
     ```

      命令查看文件系统的磁盘空间使用情况：

     ```
     bashCopy code
     df -h
     ```

5. **文件操作**：

   - 使用 

     ```
     cat
     ```

      命令查看文件内容：

     ```
     bashCopy code
     cat <filename>
     ```

   - 使用 

     ```
     mv
     ```

      命令移动文件或重命名文件：

     ```
     bashCopy code
     mv <source> <destination>
     ```

   - 使用 

     ```
     cp
     ```

      命令复制文件：

     ```
     bashCopy code
     cp <source> <destination>
     ```

6. **目录操作**：

   - 使用 

     ```
     cd
     ```

      命令切换工作目录：

     ```
     bashCopy code
     cd <directory>
     ```

   - 使用 

     ```
     mkdir
     ```

      命令创建新目录：

     ```
     arduinoCopy code
     mkdir <directory>
     ```

   - 使用 

     ```
     rm
     ```

      命令删除文件或目录：

     ```
     bashCopy code
     rm <file/directory>
     ```

7. **权限管理**：

   - 使用 

     ```
     chmod
     ```

      命令修改文件或目录的权限：

     ```
     bashCopy code
     chmod <mode> <file/directory>
     ```

   - 使用 

     ```
     chown
     ```

      命令修改文件或目录的所有者：

     ```
     rubyCopy code
     chown <user>:<group> <file/directory>
     ```

## RocketMQ了解吗？结构

1. **Nameserver**：Nameserver 是 RocketMQ 集群的元数据管理节点，负责管理集群中所有 Broker 的元数据信息，包括 Broker 的地址、Topic 的路由信息等。**Producer 和 Consumer 可以通过 Nameserver 查找对应的 Broker 以进行消息的发送和接收。**
2. **Broker**：**Broker 是 RocketMQ 集群的消息存储和处理节点，负责存储消息和处理消息的读写请求。**每个 Broker 包含多个 Topic 的消息存储目录，消息发送到 Broker 后会被持久化存储，并且在 Consumer 订阅该 Topic 后会被推送给 Consumer 进行消费。Broker 可以根据需要进行水平扩展，形成 Broker 集群以提高吞吐量和可用性。
3. **Producer**：Producer 是消息的**生产者**，负责生产消息并将消息发送到 RocketMQ 集群中的 Broker。Producer 可以根据需要将消息发送到特定的 Topic，并且可以选择同步发送或异步发送消息，以满足不同的业务需求。
4. **Consumer**：Consumer 是消息的**消费者**，负责从 RocketMQ 集群中的 Broker 订阅消息并进行消费。Consumer 可以根据需要订阅特定的 Topic 或者 Tag，并且可以选择集群消费或广播消费消息。在集群消费模式下，一条消息只会被 Consumer 集群中的一个 Consumer 消费；在广播消费模式下，一条消息会被 Consumer 集群中的所有 Consumer 消费。
5. **Client**：Client 是 Producer 和 Consumer 的 SDK，用于与 Nameserver 和 Broker 进行通信。Producer 和 Consumer 可以通过 Client 发送和接收消息，并且可以通过 Client 获取 Topic 的路由信息、消息的消费进度等元数据信息。
6. **Console**：RocketMQ 提供了多种监控和管理工具，其中包括 RocketMQ Console，用于监控集群状态、Topic 状态、消息堆积情况等，并且可以进行 Topic 的创建、删除、消息发送等管理操作。
7. ![image-20240409164601300](./assets/image-20240409164601300.png)

## Docker进程隔离原理，K8S用过吗？

1. ### Docker 进程隔离原理：

   Docker 使用 Linux 内核提供的容器技术，主要包括以下核心技术：

   1. **命名空间（Namespace）**：Docker 利用 Linux 的命名空间功能实现进程隔离，每个容器都有自己独立的命名空间，包括 PID 命名空间（进程隔离）、Network 命名空间（网络隔离）、Mount 命名空间（文件系统隔离）等。这使得容器内的进程看起来像是运行在一个独立的操作系统环境中，互不影响。
   2. **控制组（cgroups）**：控制组是 Linux 内核提供的一种资源限制和管理机制，Docker 使用控制组限制容器可以使用的资源，如 CPU、内存、磁盘等，从而实现资源隔离。
   3. **容器文件系统**：每个容器都有自己独立的文件系统，Docker 使用联合文件系统（UnionFS）技术实现容器文件系统的创建和管理，实现文件系统隔离。

   这些技术共同作用，使得 Docker 能够在单个主机上运行多个隔离的容器，每个容器拥有独立的进程空间、文件系统和资源限制。

   ![image-20240410081425739](./assets/image-20240410081425739.png)

2. ### Kubernetes（k8s）的原理：

   Kubernetes 是一个开源的容器编排平台，用于管理容器化应用程序的部署、扩缩容、服务发现、负载均衡等。其核心原理包括以下几个方面：

   1. **容器编排**：Kubernetes 提供了强大的容器编排能力，可以根据用户的需求对容器进行自动部署、伸缩和更新等操作，实现应用程序的高可用和弹性扩展。
   2. **服务发现和负载均衡**：Kubernetes 提供了服务抽象机制，通过 Service 对象将一组容器封装为一个服务，并且提供了负载均衡、服务发现等功能，使得应用程序可以轻松地进行通信和访问。
   3. **自动故障恢复**：Kubernetes 提供了自动故障检测和恢复机制，可以监控容器的健康状态，并在容器出现故障时自动重启或者迁移容器，保证应用程序的高可用性。
   4. **资源调度**：Kubernetes 可以根据容器的资源需求和节点的资源情况进行智能调度，将容器合理地分配到集群中的各个节点上，以实现资源的最优利用。
   5. **扩展性和可扩展性**：Kubernetes 的架构设计具有良好的扩展性，支持集群的水平扩展和垂直扩展，可以根据业务需求灵活地调整集群的规模和性能。

   总的来说，Kubernetes 提供了一套完整的容器管理和编排解决方案，使得容器化应用程序可以在分布式环境中高效、可靠地运行。

## 二叉树层序遍历







# 美团一面

## 1.cookie和session的区别？

1、数据存放位置不同：

cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、安全程度不同：

cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。

3、性能使用程度不同：

session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。

4、数据存储大小不同：

单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。

## 2.如何实现session共享，你会怎么做？

1. tomcat内置的Session复制方案，一台服务器生成一个session，会将session复制到其他所有服务器。
2. 使用session粘滞方案，通过某种形式，将用户的每次请求都固定到某台服务器上。
3. 基于session持久化方案，保存到数据库
4. 使用redis，客户端发请求，携带token，服务器获取token，查询redis。
5. https://blog.csdn.net/jhgjyfgyu/article/details/126918122?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171271453216800197015095%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171271453216800197015095&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126918122-null-null.142^v100^pc_search_result_base9&utm_term=session%E5%85%B1%E4%BA%AB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&spm=1018.2226.3001.4187

## 3.反向代理是起什么作用的？

1. **负载均衡**：反向代理可以用于负载均衡，将客户端的请求分发到多个后端服务器上，从而分担服务器的负载。通过将请求路由到空闲或负载较低的服务器，可以提高系统的整体性能和可用性。
2. **安全性**：反向代理可以作为安全屏障，隐藏真实的后端服务器，并提供安全过滤和防护功能。它可以过滤恶意请求、防止DDoS攻击、执行SSL终端、验证用户身份等操作，从而保护后端服务器免受攻击。
3. **SSL终端**：反向代理可以用于SSL终端，即在代理服务器上终止SSL/TLS连接，并将明文请求转发给后端服务器。这样可以减轻后端服务器的负担，同时提供更简单的证书管理和配置。
4. **缓存**：反向代理可以缓存静态内容或动态内容的响应，从而减少对后端服务器的请求。这可以加速响应时间、降低带宽消耗，并提高用户体验。
5. **内容转换**：反向代理可以对请求和响应进行内容转换，如压缩、加密、重定向等操作，从而提供更灵活的服务。

![image-20240410103235017](./assets/image-20240410103235017.png)

## 4.数据库主从复制

### 概述

主从复制是将主数据库的DDL和DML操作通过二进制日志传到从库服务器，然后从库对这些日志执行，保持从库和主库数据同步。

要点：

1. 主库出现问题，可以快速切换从库
2. 读写分离，减少主库压力。
3. 在从库中执行数据备份，避免备份期间影响主库的操作。



### 原理

1. 主库在事务提交时，将数据变更记录保存到binlog中。
2. 从库读取主库的binlog，并写入到从库中的中继日志relay log中。
3. 从库读取relaylog中的事件，实现与主库数据同步。
4. ![image-20240410105639323](./assets/image-20240410105639323.png)

## 5.深拷贝和浅拷贝的区别？

浅拷贝：在堆上创建一个新对象，如果对象中有引用类型，则新创建的对象中的引用类型是复制原引用类型的拷贝。

深拷贝：复制整个对象。

![image-20240410110511513](./assets/image-20240410110511513.png)

## 6.用过哪些深拷贝的方法？

1. 对拷贝类实现clonable接口，实现clone()方法，将引用类型属性进行拷贝。
2. **序列化与反序列化**：Java中的序列化机制可以实现对象的深拷贝。**将对象序列化为字节流，然后再反序列化为新对象**。
3. **使用第三方库**：有一些第三方库可以帮助实现深拷贝，比如Apache Commons的`SerializationUtils.clone()`方法。

## 7.GC分几种

1. 标记-清除
2. 复制
3. 标记-整理
4. 分代
5. 增量式垃圾回收

## 8.minGC和FullGC有什么区别？

从目标、触发条件、影响方面回答。

1. **目标**：

   - MinGC（**最小化**垃圾回收）旨在**尽量减少垃圾回收的频率和影响**，以提高应用程序的性能和响应性。它通常会尝试在更短的时间内完成垃圾回收，并且可能只清理堆中的一小部分。
   - FullGC（**完全**垃圾回收）则是在进行垃圾回收时，JVM会**尽可能地收集并释放整个堆中的所有无用对象**，而不仅仅是部分区域。它通常会导致较长的停顿时间，因为需要扫描整个堆并处理所有存活和未存活的对象。

2. **触发条件**：

   - MinGC通常由JVM**根据内存压力和垃圾回收策略自动触发**，目的是为了保持堆中的可用空间，避免出现OutOfMemoryError等内存相关的错误。
   - FullGC通常在**老年代空间不足、元空间空间不足**或者**手动调用**`System.gc()`或`Runtime.getRuntime().gc()`方法时触发。它是一种比较重量级的操作，通常发生在内存不足或者需要释放大量未使用对象时。

3. **影响**：

   - MinGC通常会产生**较短的停顿时间**，因为它只清理部分堆空间，并且通常会尽量避免引起较长时间的停顿。
   - FullGC通常会导致**较长的停顿时间**，因为它需要扫描整个堆并处理所有存活和未存活的对象，可能会影响应用程序的性能和响应性。

   [阿里二面：什么情况会发生Full GC？如何避免频繁Full GC？_什么时候会fullgc-CSDN博客](https://blog.csdn.net/Andrew_Chenwq/article/details/136634848)

## 9.消息队列起什么作用？

六个字：异步、解耦、削峰

1. **异步通信**：消息队列支持异步通信模式，生产者可以在不等待消费者处理消息的情况下继续执行。这种异步通信模式可以提高系统的响应速度和吞吐量，尤其适用于处理高并发和高负载的场景。
2. **解耦生产者和消费者**：消息队列允许生产者和消费者之间解耦，它们不需要直接通信。生产者将消息发送到队列中，而消费者从队列中接收消息。这种解耦允许系统中的各个组件独立地进行扩展和修改，提高了系统的可维护性和灵活性。
3. **削峰填谷**：消息队列可以平滑处理突发的高峰流量。当系统负载突然增加时，消息队列可以暂存消息并逐渐处理，避免系统因负载过高而崩溃或性能下降。在负载减少时，消息队列可以继续将消息提供给消费者进行处理。

## 10.MySQL的隔离级别有哪些？

1. **读未提交（Read Uncommitted）**：在这个隔离级别下，事务可以读取其他事务未提交的数据。这意味着一个事务可以读取到另一个正在进行中但尚未提交的事务的更改。这种隔离级别可能导致脏读、不可重复读和幻读问题。
2. **读已提交（Read Committed）**：在这个隔离级别下，一个事务只能读取到已经提交的其他事务的数据。这可以避免脏读，但是仍可能出现不可重复读和幻读问题。
3. **可重复读（Repeatable Read）**：在这个隔离级别下，事务在执行期间看到的数据是一致的，即使其他事务对相同的数据进行了修改。这可以避免不可重复读问题，但是仍可能出现幻读问题。
4. **串行化（Serializable）**：这是最高的隔离级别。在这个级别下，事务串行执行，确保每个事务的执行都不会被其他事务影响。这可以完全避免脏读、不可重复读和幻读问题，但是可能会导致性能下降，因为事务需要按顺序执行。

## 11.默认是什么隔离级别？

可重复读：避免脏读、不可重复读。

## 12.可重复读是什么概念？读未提交？串行化？

## 13.MySQL中的索引树是怎么维护的？

MySQL 中的索引树维护涉及到索引的创建、插入、删除和更新等操作，主要包括以下几个方面：

1. **索引的创建**：当在表上创建索引时，MySQL 会根据指定的列生成相应的 B+ 树索引。MySQL 会按照 B+ 树的性质将索引构建成平衡的树结构。
2. **插入操作**：首先会更新表中的数据页，然后，更新索引树，**如果索引节点已满，MySQL 会进行节点分裂操作，将节点分裂为两个节点，并调整父节点的指针**。
3. **删除操作**： 首先会删除数据页中的记录，然后，MySQL 会更新索引树。如果删除后的节点包含的键值数量低于最小阈值，MySQL 可能会进行节点合并操作，将节点合并到相邻的节点中，并调整父节点的指针。
4. **更新操作**：先删除旧记录，然后插入新记录。这样做的目的是避免在更新记录时对索引树进行频繁的更新操作，以提高性能。
   1. **软删除（或逻辑删除）**：首先，将需要更新的记录标记为删除状态，而不是直接从数据库中物理删除。这可以通过在记录中添加一个标识字段（如状态字段）来实现，或者通过记录到另一个表中（如历史记录表）来实现。软删除意味着在逻辑上删除了记录，但物理上保留了它们。
   2. **插入新记录**：然后，插入一条新的记录，其中包含了更新后的数据。这样做的好处是不会改变已有记录的物理位置，因此不需要在索引树中进行频繁的更新操作。


## 14.什么叫B+树？

![image-20240413082630325](./assets/image-20240413082630325.png)



![image-20240413082745185](./assets/image-20240413082745185.png)



叶子节点存储数据，非叶子节点存储索引值。



## 15.为什么要采用这种数据结构？

1. 高效的**范围查询**
2. 减少**磁盘IO**次数
3. **插入和删除**操作效率高
4. 适合磁盘存储

## 16.Linux的命令平时用到哪些?

1. **文件和目录操作命令**：
   - `ls`：列出目录内容。
   - `cd`：切换工作目录。
   - `pwd`：显示当前工作目录。
   - `mkdir`：创建新目录。
   - `rm`：删除文件或目录。
   - `cp`：复制文件或目录。
   - `mv`：移动文件或目录。
2. **文件内容查看与编辑命令**：
   - `cat`：查看文件内容。
   - `less`：逐页查看文件内容。
   - `head`：显示文件头部内容。
   - `tail`：显示文件尾部内容。
   - `vi` 或 `vim`：文本编辑器。
3. **文件权限与用户管理命令**：
   - `chmod`：修改文件权限。
   - `chown`：修改文件所有者。
   - `chgrp`：修改文件所属组。
   - `useradd`：添加新用户。
   - `passwd`：设置用户密码。
4. **系统信息查看命令**：
   - `uname`：显示系统信息。
   - `df`：显示磁盘空间使用情况。
   - `free`：显示内存使用情况。
   - `top`：实时显示系统资源占用情况。
   - `ps`：显示进程信息。
   - `uptime`：显示系统运行时间和负载。
5. **网络命令**：
   - `ping`：测试网络连通性。
   - `ifconfig` 或 `ip`：显示和配置网络接口信息。
   - `netstat`：显示网络状态。
   - `ssh`：远程登录其他主机。
   - `scp`：在本地主机和远程主机之间复制文件。
6. **压缩和解压命令**：
   - `tar`：创建和提取归档文件。
   - `gzip`：压缩文件。
   - `gunzip`：解压缩文件。
7. **其他常用命令**：
   - `grep`：在文件中搜索指定模式。
   - `find`：在文件系统中查找文件。
   - `wc`：统计文件中的行数、字数和字符数。
   - `echo`：输出文本。
   - `date`：显示或设置系统日期和时间。

## 17.Linux中查看某个进程占用率较高的话，用哪个命令？

top

## 18.我们想查找一个日志文件，空指针异常，查这个关键字用哪个命令查找？ (不清楚)

以下是使用 `grep` 命令查找包含 "空指针异常" 关键字的日志文件的示例：

```
grep "空指针异常" /path/to/logfile
```

其中 `/path/to/logfile` 是日志文件的路径。这将会在日志文件中查找包含 "空指针异常" 关键字的行，并将它们输出到标准输出。

递归搜索某个目录下的所有日志文件，可以添加 `-r` 选项：

```
grep -r "空指针异常" /path/to/directory
```

这样会在指定目录下的所有文件中搜索匹配的字符串。

忽略大小写进行搜索，可以添加 `-i` 选项：

```
grep -i "空指针异常" /path/to/logfile
```

## 19.设计模式接触过哪些？

1. 门面模式
2. 适配器模式
3. 注册器模式





# 招银后端 一面

## 1. MySQL 优化？（放开讲讲）

SQL语句：

1. 使用select *
2. 使用union all 代替 union
3. 使用join left小表驱动大表
4. 使用 in 的时候，数据量不要大于1000条。
5. 多使用limit



索引优化：

1. 最左匹配原则
2. 索引列不参与计算
3. 索引列不使用函数
4. 模糊查询
5. or连接的列必须都为索引
6. not in not exist
7. 不要建立太多索引
8. 索引定期删除
9. 经常更新的字段不要建立索引
10. 使用联合索引
11. where order by groud by 的字段建立索引



表优化：

1. 为字段设立合适的数值，能用数值类型表示就不要用字符串

2. 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循:

   - 不是频繁修改的字段。
   - 不是 varchar 超长字段，更不能是 text 字段。

   ```
   正例:商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。
   ```

   2.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明:如果预计2年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

   3.【推荐】id必须是主键，每个表必须有主键，且保持增长趋势的， 小型系统可以依赖于 MySQL 的自增主键，大型系统或者需要分库分表时才使用内置的 ID 生成器

   4.【强制】id类型没有特殊要求，必须使用bigint unsigned，禁止使用int，即使现在的数据量很小。id如果是数字类型的话，必须是8个字节。参见最后例子

   - 方便对接外部系统，还有可能产生很多废数据
   - 避免废弃数据对系统id的影响
   - 未来分库分表，自动生成id，一般也是8个字节

   5.【推荐】字段尽量设置为 NOT NULL， 为字段提供默认值。 如字符型的默认值为一个空字符值串’’;数值型默认值为数值 0;逻辑型的默认值为数值 0;

   6.【推荐】每个字段和表必须提供清晰的注释

   7.【推荐】时间统一格式:‘YYYY-MM-DD HH:MM:SS’

   8.【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间,





1. 表的优化设计（参考阿里开发手册)
   1. 设置合适的数值
   2. 设置合适的字符串类型

2. 索引优化

   

   1. 为常作为where,order by ,group by 的字段创建索引
   2. 为字段区分度高的字段创建索引
   3. 使用联合索引
   4. 控制索引的数量

   

   

   1. 避免索引失效的操作：例如最左，范围查询右边，索引列进行运算操作，使用or连接，等

3. sql语句优化
   1. select语句指定字段名称
   2. 避免使用子查询，子查询优化为join操作
   3. 避免使用or
   4. where从句中禁止对列进行函数

4. 主从负载、读写分离，不让数据的写入，影响读操作

5. 分库分表

6. **硬件和操作系统层面优化：**
   - 硬件方面：CPU 可用性、内存大小、磁盘读写速度、网络带宽等。
   - 操作系统方面：应用文件句柄数、网络配置等。
   - 这部分的优化通常由数据库管理员或者运维人员来完成，目的是提高 MySQL 的性能，并确保资源的合理利用，避免资源浪费。

7. **架构设计层优化：**
   - 搭建 **MySQL 主从集群**或主主集群，以确保高可用性。
   - **读写分离设计**，避免读写冲突，提升性能。
   - **分库分表**，降低单个服务器的负载压力，提升查询效率。
   - 引入高效的分布式数据库，如 Redis、MongoDB，缓解 MySQL 的访问压力并提升检索性能。

8. **程序配置优化：**
   - MySQL 的配置优化，通过修改配置文件（如 my.cnf）来调整 MySQL 的行为。比如调整最大连接数、开启 binlog 日志、调整缓存池等。
   - 配置项的修改需要根据实际情况和使用场景来调整，而不仅仅依赖于默认配置。

9. **SQL 执行优化：**
   - 针对 SQL 查询进行优化，包括索引的设计、查询语句的优化、避免全表扫描等。

## 2. 创建索引的要求，方法，规范?

**要求：**

1. 为常作为**where**,order by ,group by 的字段创建索引
2. 使用**联合**索引
3. 控制索引的**数量**
4. **数据量**超过300的表应该有索引；
5. **频繁**进行数据操作的表，不要建立太多的索引；
6. **删除**无用的索引，避免对执行计划造成负面影响；

**方法：**

1. **单列索引：** 为单个字段创建索引。

   ```sql
   CREATE INDEX index_name ON table_name(column_name);
   ```

2. **复合索引：** 为多个字段组合创建索引，可以优化包含多个条件的查询。

   ```sql
   CREATE INDEX index_name ON table_name(column1, column2);
   ```

3. **唯一索引：** 确保索引列的值唯一。

   ```sql
   CREATE UNIQUE INDEX index_name ON table_name(column_name);
   ```

4. **全文索引：** 用于全文搜索的索引类型，适用于文本字段的搜索。

   ```sql
   CREATE FULLTEXT INDEX index_name ON table_name(column_name);
   ```

**规范：**

1. **命名规范：** 索引命名应当具有描述性，清晰表达索引的用途和含义。

2. **避免过多索引：** 不应该为每个字段都创建索引，要根据实际查询需求和性能需求来合理选择创建索引的字段。

3. **定期维护索引：** 定期检查索引的使用情况，根据实际情况调整索引结构，删除不再需要的索引，避免索引失效和冗余。

   

## 3. 索引失效的场景？

https://blog.csdn.net/guoqi_666/article/details/122484441?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171288190016800211531921%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171288190016800211531921&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122484441-null-null.142^v100^pc_search_result_base9&utm_term=%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF&spm=1018.2226.3001.4187

### 1. 不满足最左匹配原则

### 2. 使用了 SELECT *

- **索引有效与否：** 一般来说，如果查询语句使用了 SELECT *，即查询了表的所有列，数据库可能会选择全表扫描而不是使用索引。

### 3. 索引列上有计算

- **索引有效与否：** 如果查询条件或者索引列上有计算操作，例如对索引列进行数学计算或字符串拼接，索引可能无法有效使用，导致索引失效。

### 4. 索引列使用了函数

- **索引有效与否：** 当查询条件中对索引列使用了函数，例如对索引列进行了 UPPER()、LOWER() 等函数操作时，索引可能会失效，因为函数会导致索引列无法直接匹配。

### 5. 字段类型不同

- **索引有效与否：** 如果查询条件中的列与索引列的类型不匹配，例如对字符列使用数值比较，或对数值列使用字符串比较，索引可能会失效。

### 6. LIKE 左边包含 %

- **索引有效与否：** 当 LIKE 查询中，通配符 % 出现在字符串的左边时，索引可能会失效，因为无法利用索引进行前缀匹配。

### 7. 列对比

- **索引有效与否：** 如果查询条件中进行了列与列的对比操作，例如 WHERE column1 = column2，索引可能无法有效使用。

### 8. 使用 OR 关键字

- **索引有效与否：** 当查询条件中使用了 OR 关键字，例如 WHERE column1 = value1 OR column2 = value2，索引可能会失效。

### 9. NOT IN 和 NOT EXISTS

#### 9.1 IN 关键字

- **索引有效与否：** IN 关键字通常能够有效使用索引，但是如果 IN 子查询返回的结果集较大，可能会导致索引失效。

#### 9.2 EXISTS 关键字

- **索引有效与否：** EXISTS 关键字通常能够有效使用索引，但是需要注意 EXISTS 子查询的优化。

#### 9.3 NOT IN 关键字

- **索引有效与否：** NOT IN 关键字通常无法有效使用索引，可能会导致全表扫描。

#### 9.4 NOT EXISTS 关键字

### 10. ORDER BY 的坑

#### 10.1 哪些情况走索引？

在 SQL 中，ORDER BY 用于对查询结果进行排序，它的使用涉及到索引的优化问题。

##### 10.1.1 满足最左匹配原则

- 如果 ORDER BY 子句中的列顺序与联合索引的创建顺序一致，那么数据库可能会使用该索引来执行排序。

##### 10.1.2 配合 WHERE 一起使用

- ORDER BY 还可以与 WHERE 子句一起使用，并且遵循最左匹配原则。如果 WHERE 子句中使用了联合索引的前缀列，并且 ORDER BY 子句中接着使用了联合索引的后续列，那么数据库可能会使用该索引来执行排序。

#### 10.2 哪些情况不走索引？

在某些情况下，ORDER BY 可能不会使用索引，导致索引失效。

##### 10.2.1 没有加 WHERE 或 LIMIT

- 如果 ORDER BY 子句中没有加上 WHERE 或 LIMIT 关键字，那么该 SQL 查询可能不会使用索引，而是进行全表扫描。

##### 10.2.2 对不同的索引进行 ORDER BY

- 如果在 ORDER BY 子句中对不同的索引进行排序，那么可能不会使用索引，而是导致索引失效。

##### 10.2.3 不满足最左匹配原则

- 如果 ORDER BY 子句中的条件不满足联合索引的最左匹配原则，那么可能不会使用索引，而是导致索引失效。

##### 10.2.4 不同的排序规则

- 如果 ORDER BY 子句中的多个列具有不同的排序规则，那么可能不会使用索引，而是导致索引失效。

## 4.写一个SQL语句， 要找出表 A 中 重复的业务字段数据b

假设我们有一个名为 `employees` 的表，其中包含员工信息，我们想找出重复的员工姓名。假设员工姓名存储在名为 `name` 的列中，那么我们可以使用以下 SQL 语句来查找重复的员工姓名：

```sql
SELECT name, COUNT(*) AS duplicate_count
FROM employees
GROUP BY name
HAVING COUNT(*) > 1;
```

这条 SQL 语句将会从 `employees` 表中选择员工姓名，并统计每个姓名出现的次数。然后使用 HAVING 子句筛选出出现次数大于 1 的姓名，即表示重复的员工姓名。

## 5. 现在有一个交易性的数据，日增长量可能能达到千万级别的数据，交易完成之后数给出一些设计数据就不会发生变化了，但是会频繁的查询数据。请针对这个场景据库中表的建议？

针对这样的场景，数据库表的设计应该考虑到以下几个方面：

1. **合适的索引设计：** 对于频繁查询的字段，应该建立适当的索引来加速查询操作。
2. **分区表：** 如果数据量很大，可以考虑使用分区表来优化查询性能。通过按照时间范围或其他逻辑进行分区，可以将数据分散存储在不同的物理文件中，减少单个查询涉及的数据量，提高查询效率。
3. **定期维护和优化：** 对于大型数据表，定期进行索引重建、统计信息更新等维护操作是非常重要的。这有助于保持查询性能的稳定性，避免由于数据量增长导致的性能下降。
4. **缓存和缓存策略：** 对于一些频繁访问但不经常变化的数据，可以考虑使用缓存来加速访问速度。
5. **垂直拆分和水平拆分：** 垂直拆分是指将表按照列进行拆分，将不同的列存储在不同的表中。水平拆分是指将表按照行进行拆分，将不同的行存储在不同的表或不同的数据库中。
6. **合理的服务器配置：** 对于处理大数据量的数据库，服务器的硬件配置也非常重要。要根据数据库的负载情况和性能需求，选择合适的服务器配置，包括 CPU、内存、存储和网络等方面。

## 6. 我答的分库分区分表、交易和查询分为两个数据库等，所以他问了分库分区分表，怎么分？（场景题确实不会，问问大佬们，评论教教我，感谢）

#### 1. 分库（Sharding）：

- 水平分库：
  - 根据交易时间范围等规则将数据分散存储到多个数据库中。
  - 可以根据交易日期将数据分散到不同的数据库中，例如每个月一个数据库。
  - 分库可以减少单个数据库的负载压力，并提高并发能力。

#### 2. 分表（Sharding）：

- 水平分表：
  - 将主要交易表按照时间范围等规则分成多个子表，每个子表存储一段时间内的交易数据。
  - 例如，可以按照每天或每周创建一个新的交易表，将当天或当周的交易数据存储其中。
  - 分表可以降低单表数据量，提高查询性能。

#### 3. 分区（Partitioning）：

- 按时间范围分区：
  - 在每个交易子表中使用 MySQL 的分区功能，将数据按照时间范围进行分区。
  - 例如，每个交易子表可以按照交易日期范围分成多个分区，每个分区代表一个时间段。
  - 分区可以优化查询性能，并且方便管理历史数据。

## 7.Spring中的事务是用来干什么的？

在 Spring 中，事务用于管理对数据库等持久化存储的操作，以确保**数据的一致性**、**完整性**和**可靠性**。事务可以保证一组相关操作要么全部成功提交，要么全部失败回滚，从而保证数据库的数据不会处于不一致的状态。

具体来说，Spring 中的事务功能主要用于以下几个方面：

1. **保证数据一致性：** 当一个业务操作涉及多个数据库操作时，通过事务管理可以保证这些操作要么全部成功执行，要么全部失败回滚，从而保持数据的一致性。
2. **确保事务的原子性：** 事务能够保证在一个事务中的所有操作要么全部完成，要么全部失败回滚，从而确保事务的原子性，即不可分割性。
3. **管理并发访问：** 通过事务管理可以解决多个用户并发访问数据库时可能出现的数据竞争和冲突问题，确保数据的完整性和可靠性。
4. **提高系统性能：** 事务管理可以通过合理地控制事务的范围和粒度，减少事务的锁定时间，从而提高系统的并发性能和吞吐量。
5. **实现业务逻辑的一致性：** 通过事务管理可以将业务逻辑和数据操作绑定在一起，确保业务逻辑的正确执行，并在必要时进行回滚和重试。

总的来说，Spring 中的事务管理提供了**一种可靠的机制来管理对数据库等持久化存储的操作**，保证了数据的一致性和可靠性，是开发中非常重要的一部分。

## 8.事务的实现方式？

### 1. 编程式事务管理

- **特点：** 通过编写代码显式地控制事务的开始、提交和回滚。
- **适用场景：** 对于一些需要高度灵活性和定制化的事务管理场景，或者在没有 AOP 支持的环境中使用。

### 2. 基于 TransactionProxyFactoryBean 的声明式事务管理

- **特点：** 基于 Spring 的 AOP 功能，在 XML 配置文件中通过 TransactionProxyFactoryBean 来配置事务管理器和事务属性。
- **适用场景：** 适用于需要在 XML 配置中明确声明事务切面和事务属性的场景。

### 3. 基于 @Transactional 注解的声明式事务管理

- **特点：** 使用注解方式在方法级别声明事务，通过 @Transactional 注解来指定事务的属性。
- **适用场景：** 适用于简单的事务场景，能够简化配置，提高开发效率，推荐在基于注解的 Spring 应用中使用。

### 4. 基于 AspectJ AOP 配置（注解）事务

- **特点：** 使用 AspectJ AOP 来实现对方法的拦截和事务管理，可以更细粒度地控制事务。
- **适用场景：** 适用于需要在方法调用前后进行更细粒度控制或者需要对具体类的方法进行事务增强的场景。



### 1. 编程式事务管理

```java
public class TransactionalService {
    
    private TransactionTemplate transactionTemplate;
    
    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }
    
    public void performTransaction() {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // 在事务中执行业务逻辑
                // 可以在这里调用beginTransaction()、commit()、rollback()等事务管理相关的方法
            }
        });
    }
}
```

### 2. 基于 TransactionProxyFactoryBean 的声明式事务管理

```xml
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<bean id="transactionalService" class="com.example.TransactionalService"/>

<bean id="transactionProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
    <property name="transactionManager" ref="transactionManager"/>
    <property name="target" ref="transactionalService"/>
    <property name="transactionAttributes">
        <props>
            <prop key="perform*">PROPAGATION_REQUIRED</prop>
        </props>
    </property>
</bean>
```

### 3. 基于 @Transactional 注解的声明式事务管理

```java
@Service
public class TransactionalService {

    @Autowired
    private SomeRepository someRepository;

    @Transactional
    public void performTransaction() {
        // 在方法内执行业务逻辑
        // 方法执行过程中发生异常会触发事务回滚
    }
}
```

### 4. 基于 AspectJ AOP 配置（注解）事务

```java
@Aspect
@Component
public class TransactionAspect {

    @Autowired
    private PlatformTransactionManager transactionManager;

    @Around("@annotation(org.springframework.transaction.annotation.Transactional)")
    public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            Object result = joinPoint.proceed();
            transactionManager.commit(status);
            return result;
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

## 9.事务的注解是什么？

   @Transactional

## 10.如果希望在A方法中调用B方法时，即使B方法报错也不回滚A方法的数据，怎么办？

通过在方法 B 上使用 `@Transactional(propagation = Propagation.REQUIRES_NEW)` 注解来实现。这样做将会使方法 B 开启一个新的事务，与方法 A 的事务分开，即使方法 B 报错回滚，也不会影响方法 A 的数据。

## 11.设计模式有了解吗？

1. 单例模式
2. 门面模式
3. 适配器模式
4. 注册器模式
5. 责任链模式

## 12.单例模式？

单例模式保证**一个类只有一个实例对象**，并提供了一种全局的访问方式，使得该实例可以被系统中的任何地方访问

## 13.单例模式应用场景？

1. **资源共享：** 当多个部分需要访问同一个资源时，可以使用单例模式确保只有一个实例存在，避免资源的多重创建和浪费。
2. **工具类和配置类：** 单例模式常用于创建工具类和配置类，例如日志管理器、数据库连接池、线程池、配置文件解析器等。这些类在应用程序中通常只需要一个实例，通过单例模式可以确保全局唯一性。
3. **全局缓存管理：** 在需要缓存数据的场景中，可以使用单例模式管理全局的缓存对象，以提高数据访问效率。
4. **线程池管理：** 在需要管理多个线程的场景中，可以使用单例模式创建线程池管理器，以确保所有线程共享同一个线程池对象。
5. **日志记录器：** 单例模式常用于创建日志记录器，以便在应用程序中的任何地方记录日志信息，而无需多次创建日志记录器实例。

## 14.写一下单例模式

使用了懒汉式单例模式的实现方式：

```java
public class Singleton {

    // 私有静态变量，用于保存唯一实例
    private static Singleton instance;

    // 私有构造方法，防止外部通过 new 创建实例
    private Singleton() {
    }

    // 公有静态方法，用于获取唯一实例
    public static Singleton getInstance() {
        // 懒汉式，延迟初始化，当第一次使用时才创建实例
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    // 其他方法
    public void showMessage() {
        System.out.println("Hello, World!");
    }
}
```

在这个示例中，`Singleton` 类使用了懒汉式单例模式的实现方式。在 `getInstance()` 方法中，如果 `instance` 为空，则创建一个新的实例；如果 `instance` 不为空，则直接返回现有的实例。这样可以确保 `Singleton` 类只有一个实例，并且提供了一个全局访问点来获取该实例。

下面是使用该单例类的示例代码：

```java
javaCopy codepublic class Main {
    public static void main(String[] args) {
        // 获取 Singleton 实例
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();

        // 检查是否为同一个实例
        if (singleton1 == singleton2) {
            System.out.println("两个实例是相同的实例");
        } else {
            System.out.println("两个实例不是相同的实例");
        }

        // 调用 Singleton 实例的方法
        singleton1.showMessage();
    }
}
```

以上代码将输出以下结果：

```java
两个实例是相同的实例
Hello, World!
```



饿汉式单例模式是指在类加载时就创建实例，而不是在第一次使用时才创建实例。这样可以保证在任何时候调用 `getInstance()` 方法都能获得同一个实例。下面是一个使用饿汉式单例模式的示例：

```java
javaCopy codepublic class Singleton {

    // 类加载时就创建实例，并且保证唯一性
    private static Singleton instance = new Singleton();

    // 私有构造方法，防止外部通过 new 创建实例
    private Singleton() {
    }

    // 公有静态方法，用于获取唯一实例
    public static Singleton getInstance() {
        return instance;
    }

    // 其他方法
    public void showMessage() {
        System.out.println("Hello, World!");
    }
}
```



## 15. 手撕：第一个只出现一次的字符

leetcode 387



作者：yeesophy
链接：[https://www.nowcoder.com/interview/center?entranceType=%E5%AF%BC%E8%88%AA%E6%A0%8F](https://www.nowcoder.com/interview/center?entranceType=导航栏)
来源：牛客网-





# 哈罗出行Java实习生

## 1.arrayList和LinkedList在实现层面和使用场景有什么差别？ 

实现层面：动态数组 vs 双向链表

ArrayList 适合于随机访问较多的场景，而 LinkedList 则适合于频繁插入和删除操作的场景。

## 2.arrayList为什么查询的时候比较快？ 

- ArrayList 支持高效的随机访问，因为它可以直接通过索引来访问数组中的元素，时间复杂度为 O(1)。
- LinkedList 不支持直接的随机访问，如果需要访问某个索引位置的元素，需要从链表头或尾开始顺序遍历链表，时间复杂度为 O(n)。

## 3.arrayList和LinkedList扩容上面有什么差别？

1. **ArrayList 的扩容**：
   - 当 ArrayList 的容量不足以容纳新元素时，它会进行扩容操作。
   - ArrayList 会创建一个新的更大的数组，并将原数组中的元素复制到新数组中。
   - 默认情况下，ArrayList 的扩容策略是每次扩容增加当前容量的一半，即增加原容量的 50%。
   - 扩容操作会导致重新分配内存空间和复制元素，因此在扩容时会有一定的时间开销。
2. **LinkedList 的扩容**：
   - 由于 LinkedList 是基于链表实现的，它在插入和删除操作时不需要像 ArrayList 那样进行扩容操作。
   - 在 LinkedList 中，每个元素都包含了对前一个和后一个元素的引用，因此在插入和删除操作时只需修改相邻节点的指针即可，不需要移动其他元素或重新分配内存空间。

综上所述，ArrayList 在扩容时需要**重新分配内存空间和复制元素**，而 LinkedList 则**不需要进行显式的扩容操作**，因为它的内部结构并不会随着元素数量的增加而发生变化。 

## 4.arrayList和LinkedList是线程安全的吗？ 

1. **ArrayList**：
   - ArrayList 不是线程安全的数据结构，即在多线程环境下，如果多个线程同时访问或修改同一个 ArrayList 实例，可能会导致不确定的结果。
   - 如果需要在多线程环境下使用 ArrayList，可以使用 Collections 工具类提供的 `synchronizedList` 方法将 ArrayList 转换为线程安全的列表，或者使用并发容器类如 `CopyOnWriteArrayList`。
2. **LinkedList**：
   - 同样地，LinkedList 也不是线程安全的数据结构。
   - 在多线程环境下，如果多个线程同时访问或修改同一个 LinkedList 实例，可能会导致竞态条件和不一致的结果。
   - 如果需要在多线程环境下使用 LinkedList，可以采用与 ArrayList 相同的方法，即使用 `Collections.synchronizedList()` 方法或者并发容器类。

## 5.本地有个文件需要发送到另外一台机器？

1. **使用文件传输协议（FTP）**：
   - 可以使用 FTP 客户端软件（如 FileZilla）连接到目标机器上的 FTP 服务器，并将文件上传到服务器上。
   - 或者，你可以在目标机器上设置一个 FTP 服务器，然后通过 FTP 客户端上传文件到该服务器上。
2. **使用文件共享**：
   - 如果两台机器在同一局域网内，你可以设置文件共享，并将文件复制到共享文件夹中。然后在目标机器上访问共享文件夹，将文件复制到目标位置。
   - 使用网络文件系统（NFS）或者 Server Message Block（SMB）等协议可以实现文件共享。
3. **使用 SCP 或 SFTP**：
   - SCP（Secure Copy Protocol）和 SFTP（SSH File Transfer Protocol）都是通过 SSH 进行加密传输的文件传输协议。
   - 你可以使用 SCP 或 SFTP 客户端命令行工具（如 scp 或 sftp）将文件从本地传输到目标机器上。
4. **使用云存储服务**：
   - 如果两台机器都能够访问互联网，你可以将文件上传到云存储服务（如 Dropbox、Google Drive、OneDrive 等），然后在目标机器上下载文件。
5. **使用邮件或消息传递应用**：
   - 如果文件较小，你可以将文件作为附件通过电子邮件发送给目标机器上的用户。
   - 或者使用即时消息传递应用（如微信、WhatsApp）发送文件。

作者：墨离尘&
链接：https://www.nowcoder.com/discuss/392436990824787968?sourceSSR=enterprise
来源：牛客网





# 小米日常实习

## 1、谈谈你对集合的理解

https://blog.csdn.net/weixin_42085994/article/details/136062001

集合是**存储对象的容器，可以存放不同类型的对象**。java集合框架主要包括单列集合和双列集合，Collection和Map，分别为Set List Quenen，HashMap ConcurrentHashMap HashTable TreeMap

![image-20240414080054065](./assets/image-20240414080054065.png)



与数组的区别：

1. 长度可变
2. 只能存储引用数据类型
3. 可以存储不同的数据类型

## 2、List、Set、Map有什么区别

List：有序集合，元素可以重复，主要实现类，ArrayList，LInkedList

Set：元素不可重复，HashSet基于哈希表、TreeSet基于红黑树，LinkedHashSet

Map：键值对，key不可重复，无序。HashMap、TreeMap

## 3、List接口有哪些实现类，有什么区别

ArrayList、LinkedList

底层结构：动态数组，双向链表

快速随机访问：ArrayList有索引，查询快，实现了RandomAccess接口。

内存占用：ArrayList空间浪费在于会预留一定空间，添加第一个元素开始扩容为10，后续以1.5倍进行扩容。LinkedList空间占用在于存放前驱引用和后驱引用。

头尾增删效率：ArrayList默认在尾部添加，头部增删时间复杂度O（n），LinkedList头尾增删都为O(1)



## 4、Set有哪些实现类、用过TreeSet吗

HashSet、LinkedHashSet、TreeSet

底层数据结构：哈希表、哈希表+双向链表、红黑树

应用场景：不需要保证元素的插入和取出顺序、保证元素插入取出顺序、对元素排序自定义规则



## 5、Hashmap安全吗？为什么不安全

不安全；

结论：jdk1.7中，链表的插入是头插法，多线程操作时容易造成链表死循环。jdk1.8中，在putVal方法中，多线程操作会造成数据覆盖，体现在发生hash碰撞和++size时，hash碰撞导致数据被覆盖，++size导致链表长度少增加一个，导致数据覆盖。

https://blog.csdn.net/swpu_ocean/article/details/88917958?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171305467816800211585231%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171305467816800211585231&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88917958-null-null.142^v100^pc_search_result_base9&utm_term=HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8&spm=1018.2226.3001.4187

## 6、聊聊Hashmap的扩容机制

第一次添加元素时初始化数组为16，扩容因子为0.75，每次扩容都是旧容量*0.75的两倍。



扩容方法为rezie()，

首先，哈希运算得到哈希表索引；

判断是否为空，为空添加元素，结束；

判断是否为树节点，树节点，红黑树添加，结束；

添加到链表，判断链表长度是否大于8，进入树化，判断数组是否大于64，数组大于64，进行树化；

反之，进行数组扩容，将链表拆分。

## 7、ConcurrentHashMap 为什么安全

https://blog.csdn.net/weixin_48499022/article/details/107617132?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171305620816800197043383%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171305620816800197043383&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107617132-null-null.142^v100^pc_search_result_base9&utm_term=ConcurrentHashMap%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8&spm=1018.2226.3001.4187

底层结构依然是：哈希表+链表+红黑树

jdk1.7：采用分段锁

jdk1.8：CAS+synchronized





## 8、CAS是什么

乐观锁的思想实现

CAS是Compare-And-Swap（比较并交换）的缩写，是一种轻量级的同步机制，主要用于实现多线程环境下的无锁算法和数据结构，保证了并发安全性。它可以在不使用锁（如synchronized、Lock）的情况下，对共享数据进行线程安全的操作。

CAS操作主要有三个参数：要更新的内存位置、期望的值和新值。CAS操作的执行过程如下：

首先，获取要更新的内存位置的值，记为var。
然后，将期望值expected与var进行比较，如果两者相等，则将内存位置的值var更新为新值new。
如果两者不相等，则说明有其他线程修改了内存位置的值var，此时CAS操作失败，需要重新尝试。
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/Aqting/article/details/129465893

## 9、RetreenLock是什么？

实现了Lock接口，是一个可重入且独占式的锁，和synchronized锁类似。不过，更加灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁的高级功能。

默认使用非公平锁。

公平锁：当锁被释放时，先申请锁的线程先获取锁。

非公平锁：锁释放后，线程获取锁是随机的或者按照其它优先级。



可中断锁：获取锁的过程中，可以中断这个请求。

synchronized不可中断。



可重入锁：当线程获取某个锁后，还可以继续获取它，可以递归调用，而不会发生死锁。





与Synchorinzed锁的区别：

- 可以指定使用公平锁，而Synchronized只能使用非公平锁

- 可以超时中断，获取锁的过程中，可以取消等待，而Synchronized只能等待。

- 依赖于API实现，而Sychronized依赖于JVM。

- 可以实现选择性通知，使用Condition

  - ```java
    import java.util.concurrent.locks.Condition;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    class SharedResource {
        private final Lock lock = new ReentrantLock();
        private final Condition condition = lock.newCondition();
        private boolean conditionMet = false;
    
        public void waitForCondition() throws InterruptedException {
            lock.lock();
            try {
                while (!conditionMet) {
                    condition.await(); // 等待条件满足
                }
                // 执行条件满足后的操作
                System.out.println("Condition is met!");
            } finally {
                lock.unlock();
            }
        }
    
        public void signalCondition() {
            lock.lock();
            try {
                conditionMet = true; // 设置条件为满足
                condition.signal(); // 通知等待该条件的线程
            } finally {
                lock.unlock();
            }
        }
    }
    
    public class ConditionExample {
        public static void main(String[] args) {
            SharedResource sharedResource = new SharedResource();
    
            // 等待条件的线程
            Thread waitingThread = new Thread(() -> {
                try {
                    sharedResource.waitForCondition();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
    
            // 触发条件的线程
            Thread signalingThread = new Thread(() -> {
                try {
                    Thread.sleep(2000); // 模拟一些操作
                    sharedResource.signalCondition(); // 触发条件
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
    
            waitingThread.start();
            signalingThread.start();
        }
    }
    
    ```

    

## 10、谈谈对 I/O 的理解

https://www.bilibili.com/video/BV1aF411X7gC/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=138eaa25438e4a201d46b3c44c9ac52f

1. Java中IO的基础知识
   - IO流即Input/Output，数据输入到内存中是输入流，输出到外部存储是输出流（如数据库、文件等）
   - 字节流：InputStream、OutputStream
   - 字符流：Reader、Writer
   - 字节缓冲流：BufferInputStream、BufferOutputStream
   - 字符缓冲流：BufferReader、BufferWriter
2. IO使用到的设计模式
   - 装饰器模式：增强现有类的功能，如FileInputStream是InputStream的装饰器模式体现
   - 适配器模式：数据类型转换，如InputStreamReader是字节流转换为字符流，OutputStreamWriter为字符流转换为字节流。
   - 工厂模式：Fils.newInputStream方法
   - 观察者模式：Java NIO（缓冲区、管道、选择器）中的文件目录监听使用的就是观察者模式，观察者和被观察者，监听变化然后动态更新。
3. Java中IO的几种模型
   - BIO：同步阻塞IO
   - NIO：同步非阻塞IO、IO多路复用
   - AIO：异步IO

## 11、MySQL的几中隔离级别

读未提交

读已提交

可重复读

串行化

## 12、什么是脏读、幻读

脏读：读取到未提交的数据

幻读：事务A查询到一些数据，然后事务B插入了新数据，事务A继续查询到了新数据。

## 13、什么是索引？

索引是帮助MySQL高效获取数据的数据结构，索引相当于一本书的目录。

常见的索引结构：B树、B+树、Hash、红黑树，MySQL中的InnoDB和MyIsam都是使用B+树。

## 14、了解哪些MySQL的执行引擎（只知道InnoDB，他想问我另外一个，我不会，还想让我比较他们的区别）

InnoDB、MyIsam(MySQL5.5之前)

是否支持**行级锁**：MyIsam只支持表级锁，一锁就是锁住整张表。

是否支持**事务**：MyIsam不支持事务。

是否支持**外键**：MyIsam不支持外键。

是否支持**数据库安全恢复**：My不支持。

MyIsam是**非聚集索引**。

MyIsam**不支持MVCC**。



1. 行级锁
2. 事务
3. 外键
4. 数据库恢复
5. 非聚集索引
6. MVCC

## 15、索引从数据结构上来看有哪些索引（只知道B+树的索引，他问我Hash索引）

B树、B+树、Hash表、位图





InnoDB采用自适应的哈希索引，每个哈希桶都是一个B+树，有效减少哈希冲突链的长度。提高了索引效率。



为什么不用hash索引？

不支持顺序和范围查询，并且每次都只能IO一个。

## 16、为什么用B+树有哪些优点

https://www.bilibili.com/video/BV1pJ4m1j7Pm/?spm_id_from=333.880.my_history.page.click&vd_source=138eaa25438e4a201d46b3c44c9ac52f

1. 更高效的范围查询
2. IO次数更少
3. 更稳定的查询效率

## 17、为什么不用b树

B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。

B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/database/mysql/mysql-index.html

## 18、Redis的基本数据类型

String、Lis、Set、Zset、Hash

![image-20240415091337100](./assets/image-20240415091337100.png)

## 19、Zset的底层实现

https://www.bilibili.com/video/BV1kh411x7Jc/?spm_id_from=333.337.search-card.all.click&vd_source=138eaa25438e4a201d46b3c44c9ac52f

与set相比，底层新增了一个score参数，使得集合中的元素可以安装score进行有序排列，还可以通过score的范围来获取元素的列表。

```sh
zadd myset score1 value1 score2 value2
```

![image-20240415091444248](./assets/image-20240415091444248.png)

## 20、Redis是怎么保证和数据库的数据一致性

1. 双写一致性：当修改了数据库的数据的同时也要同时更新缓存的数据。
   1. 读操作：缓存命中，直接返回；缓存没有命中查询数据库，写入缓存，设定超时时间。
   2. 写操作：**延迟双删**，先删除缓存---->修改数据库---->延时一会----->删除缓存
      1. 先删除缓存还是先修改数据库
         1. 都可能出现脏数据
      2. 为什么要双删？
         1. 降低脏数据的出现
      3. 为什么要延时？
         1. 给数据库操作留足够的时间
      4. 为什么要第二次删除缓存？
         1. 防止在数据库操作期间，有其他线程读取到旧的数据并缓存到redis中。
2. 添加分布式锁
   1. 效率太低
3. redisson的读写锁
   1. 共享锁：其他线程只能读，进行读操作时添加。
   2. 排它锁：其他线程没有任何操作权限，进行写操作时添加。
   3. 强一致、性能低。
4. 异步通知
   1. 使用**MQ消息中间件**
      1. 更新数据之后，通知缓存删除。
   2. 使用基**于mysql的主从同步的Canal**
      1. 不需要修改业务代码，伪装为MySQL的一个从节点，读取mysql的binlog数据更新缓存。

## 21、Redis有事务吗？（不懂，不知道咋说）

有事务，redis事务提供了一种将多个命令打包，然后将打包的命令顺序执行的功能，该过程不会被打断。



## 22、Redis持久化的方式

RDB和AOF，

RDB：数据文件快照，fork子进程进行文件快照。性能高，数据完整性低。

AOF：记录操作命令的日志文件，将指令记录到日志文件中。性能低，数据完整性高。

## 23、AOF如果存储的文件满了要怎么处理

AOF会执行bgwriteaof命令，让AOF文件执行重写功能，压缩文件。

## 24、Redis的哨兵模式会吗？

哨兵的作用：

1. 监控：监控主从节点，定时发送info查看redis节点是否正常工作
2. 通知：通知管理员节点故障。
3. 自动故障迁移：当主节点故障，sentinel会自动将一个从节点升级为主节点。

脑裂：因为网络延迟，导致哨兵没有感知到主节点的存在，执行了自动故障迁移，过了一会，原主节点上线，当哨兵感知了之后，将原主节点降为从节点，导致大量数据丢失。

通过redis.conf进行配置，设置最少的从节点数量和缩短主从数据同步的延迟时间，达不到要求旧拒绝请求，可以避免大量的数据丢失。

## 25、谈谈Nacos的理解

注册中心，服务的注册和服务的发现。

1. 健康监测：监测服务是否正常。
2. 服务管理：服务注册和发现
3. 配置管理：动态配置
4. 订阅者查询：管理服务的订阅关系
5. 命名空间管理：如生产环境和开发环境隔离开

## 26、你怎么实现负载均衡的？

Ribbon实现负载均衡

## 27、Kafka和RabbitMQ RocketMQ的区别

[Kafka](https://so.csdn.net/so/search?q=Kafka&spm=1001.2101.3001.7020)、RabbitMQ和RocketMQ都是流行的开源消息队列系统，但它们有一些区别：

应用场景：Kafka主要用于大规模的实时数据管道和流式处理应用；[RabbitMQ](https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020)更适合消息传递和任务队列场景；RocketMQ则是针对分布式大规模数据处理和低延迟的场景。

数据存储方式：Kafka使用磁盘存储，RabbitMQ和[RocketMQ](https://so.csdn.net/so/search?q=RocketMQ&spm=1001.2101.3001.7020)使用内存存储。

消息传递的方式：Kafka和RocketMQ支持发布/订阅模式和点对点模式，RabbitMQ仅支持点对点模式。

消息的可靠性保证：Kafka和RocketMQ都支持消息的可靠性保证，包括数据备份、数据同步等机制，而RabbitMQ则提供了多种消息传递的保证机制，如消息确认和事务机制。

社区和生态系统：Kafka和RabbitMQ都有较大的社区和丰富的插件生态系统，RocketMQ在国内有很大的用户群体，但国际上的用户群体相对较小。

总之，这些消息队列系统都有各自的特点和优缺点，选择哪一个取决于你的具体需求和应用场景。

## 28、Kafka如何持久化

日志文件存储：

Kafka使用日志文件来存储消息。每个分区都有一个或多个日志文件，这些文件存储了该分区的所有消息。

当生产者发送消息时，这些消息会被追加到相应的日志文件中。

复制和备份：

Kafka的每个分区可以有多个副本（replicas），这些副本分布在集群的不同节点上。这种复制机制确保了即使在某些节点发生故障的情况下，数据仍然可用。

通过复制，Kafka实现了高可用性和容错性。如果一个节点发生故障，其他节点上的副本可以继续提供服务。

写入策略：

Kafka使用追加写入的策略，这意味着新的消息总是被追加到日志文件的末尾。这种策略提高了写入性能，并简化了数据恢复过程。

清理和压缩：

Kafka定期清理旧的日志文件，以释放存储空间。同时，它还使用压缩技术来减少存储空间的占用。

压缩可以帮助减少磁盘I/O和网络传输的开销，但需要注意的是，压缩和解压缩操作可能会增加CPU负载。

ZooKeeper的协调作用：

ZooKeeper是Kafka集群的协调者，它帮助管理Kafka的各种元数据信息，包括主题、分区和副本的位置等。这些元数据信息对于持久化机制的正常运行至关重要。

客户端配置：

Kafka客户端的配置也影响了持久化的效果。例如，配置适当的复制因子（replication factor）和保留时间（retention time）可以帮助确保数据的可靠性和可用性。

故障恢复和备份：

如果发生故障或数据丢失，Kafka可以通过其复制机制和备份策略进行恢复。通过读取其他节点上的副本，可以恢复丢失的数据。此外，定期备份整个Kafka集群或关键数据也是一个好的实践。

日志压缩（Log Compaction）（可选）：对于某些使用场景，如键值存储，可以使用日志压缩功能来只保留每个键的最新值，从而节省存储空间。

总之，Kafka通过其分布式存储架构、日志文件、复制机制和清理策略等实现了数据的持久化。这些机制确保了即使在系统故障或重启的情况下，数据仍然可用且可靠。

## 29、算法最长不重复字串





# 北京亚信科技Java实习

## 1、项目相关（负责什么模块、怎么实现的、实现细节、数据库表涉及哪些字段）

项目是我跟着网上做的一个单体项目，我把它改造成一个微服务项目，后端服务（用户服务、接口管理服务）、网关服务、模拟接口服务、订单服务、第三方服务（支付宝沙箱支付、QQ邮箱发送邮件服务），服务之间的调用主要使用了Dubbo PRC远程调用框架和RabbitMQ消息队列；

RPC远程调用的体现在于，

网关有接口统计和API鉴权功能，需要对数据库进行操作，在RPC远程调用中，后端服务作为服务提供方，网关服务作为调用方，调用后端服务的统计接口、根据accessKey获取用户接口，这些被调用的接口被统一抽取出来放到一个公共模块里面；

订单服务作为服务提供方，后端接口统计展示结果作为服务调用方，调用订单结果的展示；



RabbitMQ消息队列在体现在于，

网关服务进行接口统计的时候，使用了装饰器模式，增强过滤器链的功能，会异步等待接口调用结果，如果接口调用不成功，会发送消息对消息队列，后端服务会监听接口调用是否成功，监听器接收到消息，会让接口统计回滚。



后端服务使用邮箱登录或者注册的时候，会将发送邮件的消息的放到消息队列，第三方服务邮件发送监听器监听到消息，就会发送邮件。



订单服务生成订单的时候，会将订单生成消息放进队列里面；第三方服务进行订单支付的时候，支付成功会发送支付成功的消息到队列，订单服务有两个监听器，监听支付成功的监听器，监听到了消息就修改订单；订单超时监听器，如果订单消息没有被消费，就会进入死信队列，订单超时监听器检查该订单是否被支付，位被支付则将订单状态修改。

## 4、Java中有哪些操作字符串的类，有什么区别？

String、StringBuilder、StringBuffer



可变性：string不可变，stringbuilder和stringbuffer都提供了操作字符串的方法，例如append等。

线程安全性：string（不可变，看做常量）和stringbuffer（加了锁）线程安全，stringbuilder线程不安全。

性能：string每次修改时，会生成一个新的string对象，然后将指针指向新的对象；stringbuilder和stringbuffer都是对本身进行操作，stringbuilder的性能比stringbuffer稍高，但是有线程安全问题出现。



为什么string不可变？

1. 底层的字符数组是final类型，而且没有提供方法去改变它；
2. String类用final修饰，无法继承，避免了子类破坏string不可变。

## 5、Java容器有哪些？

两类，实现Collection接口和Map接口的容器，分别是单列集合和双列集合

单列集合主要为：List （ArrayList LinkedList）、Set（HashSet、TreeSet、LinkedHashSet)、Queen

双列集合主要为：HashMap、TreeMap、HashTable

## 6、ArrayList和LinkedList的区别？

底层结构：动态数组、双向链表；

是否支持快速随机访问：：ArrayList实现了RandomAccess接口，支持快速随机访问；

内存空间占用：ArrayList在于预留一定位置，LinkedList在于要存放前继和后驱引用。

增删效率：ArrayList在中间位置不好增删，LinkedList增删方便。

## 7、Java中创建线程的方式？

1. 继承Thread类，重写run方法；
2. 实现Runable接口，重写run方法；
3. 实现Callable接口，重写call方法，可以拿到返回值。
4. 使用EexecutorService线程池
5. 使用CompletableFuture类；
6. 使用FutureTask类



其实都是new Thread().start()创建线程

## 9、MySQL什么时候会用到索引？

查询涉及到数据的检索、排序、分组、连接以及唯一性约束等操作时，MySQL 可能会使用索引来加速查询

## 10、MySQL加索引的本质是什么？

索引其实是一种数据结构，相当于书的目录。B+树

## 11、Redis的五种基本数据类型的底层结构？

[redis的压缩列表和跳表，看这一篇文章就够了-C·3	sSDN博客](https://blog.csdn.net/weixin_61543601/article/details/124851042)



![image-20240415091337100](./assets/image-20240415091337100.png)



String：动态字符串

List：双向链表/压缩列表

Set：哈希表/整数数组

hash：哈希表/压缩列表

sorted set：跳表/压缩列表(有序集合保存的元素数量小于128个 有序集合保存的所有元素长度小于64字节)

## 12、Redis的使用场景？

缓存
缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略。所以，现在Redis用在缓存的场合非常多。

排行榜
很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。

计数器
什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时，如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。

分布式会话
集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。

分布式锁
在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。

社交网络
点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。

最新列表
Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。

消息系统
消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。
————————————————

```
                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
```

原文链接：https://blog.csdn.net/weixin_46460843/article/details/119088112



具体一点的场景：

通过Zet维护排行榜、缓存购物车信息（hash）、最新文章（list)、缓存用户id(String)、共同关注（Set）、分布式Session

## 13、Linux的基本命令？

1. 删除：rm

2. 拷贝：cp

3. 创建文件夹：mkdir

4. 启动一个java项目：

   1. ```
      java -jar path/to/project com.example.MainClass
      ```

      其中 `path/to/project` 是 Java 项目的根目录，`com.example.MainClass` 是包含 `main` 方法的 Java 类的完整类名。

5. 运行.sh脚本：./sh脚本

   1. 请确保脚本文件有可执行权限，如果没有，可以使用 `chmod +x script.sh` 命令添加可执行权限。
   2. `chmod +x script.sh` 是用于给文件 `script.sh` 添加可执行权限的命令。在 Linux 中，文件的权限分为三种：读（r）、写（w）、执行（x）





# 小米二面

## 1.动态代理?正向代理?反向代理?

https://blog.csdn.net/Dax1_/article/details/124652162?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171391920116800185879453%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171391920116800185879453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-124652162-null-null.142^v100^pc_search_result_base9&utm_term=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86&spm=1018.2226.3001.4187

正向代理：

1. 位于客户端和目标服务器之间的[代理服务器](https://so.csdn.net/so/search?q=代理服务器&spm=1001.2101.3001.7020)（中间服务器），代理的是客户端。客户端需要进行设置。
2. 使用场景：科学上网，提高访问速度（代理服务器的缓存功能），隐藏客户端真实IP（服务器端并不知道客户端的IP）



反向代理：

1. 代理服务器端来接收客户端请求，将请求分发给服务器。
2. 使用场景：API开放平台使用了Nginx的反向代理。



https://blog.csdn.net/hc1285653662/article/details/127199791?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-127199791.142^v100^pc_search_result_base9&spm=1018.2226.3001.4187

动态代理：

1. 在程序的执行过程中，动态创建对象，并代理对象。
2. 使用场景：对一段已经存在的类，不需要改变其代码，而达到增强其功能的目的。



静态代理：为每一个需要代理的类创建一个代理类，在代理类中实现需要增强的代码。



## 2.Jwt 令牌?

https://blog.csdn.net/CYK_byte/article/details/133803214?ops_request_misc=&request_id=&biz_id=102&utm_term=JWT%E4%BB%A4%E7%89%8C&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-133803214.142^v100^pc_search_result_base9&spm=1018.2226.3001.4187



1. 组成部分：标头（令牌类型和签名算法）、有效负载（传输的信息）、签名（秘钥、签名算法），HS256。

2. 首先前端将用户名和密码发送给后端，后端对用户名和密码校验成功后，会将用户 id 和其他信息作为 payload ，然后将其分别进行 Base64 编码，拼接，最后再签名，形成一个 JWT（Token）.  形成的 JWT 就形同 xxx.yyy.zzz 这种结构的字符串.

2. 后端将 JWT 字符串作为登录成功的响应结构返回给前端.  前端就可以通过 localStorage 保存到本地.  用户退出登录时删除保存的 JWT 即可.

3. 之后前端每次请求都会将 JWT 放入 HTTP Header 中的 Authorization 位（解决 XSS 和 XSRF 问题）.

4. 之后后端每次收到请求后都会先验证 JWT 的有效性.  例如，检查签名是否正确、Token 是否过期、Token 的接收方是否是自己（可选）.
   ————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
   

原文链接：https://blog.csdn.net/CYK_byte/article/details/133803214

## 3.Threadlocal的作用?怎么避免的线程安全问题

作用：ThreadLocal提供了线程的本地变量，即当创建一个变量后，每个线程对其进行访问的时候访问的是自己线程的变量。



原理：

1. 定义一个静态ThreadLocal实例，
2. 使用threadLocal.set(value)方法，内部会调用当前线程，当前线程里面维护了一个threadLocals变量，是ThreadLocalMap类型，存放value，key是当前线程。

![image-20240424101817708](./assets/image-20240424101817708.png)

## 4.布隆过滤器如何解决redis 缓存穿透

什么是缓存穿透？

当一个数据在数据库和Redis中都不存在时，请求访问这个数据时，查询Redis查询不到，继续查询数据库，依然查询不到。



两种解决方案：

1. 为数据库中不存在的数据设置Redis缓存为null。
2. 使用布隆过滤器：
   1. 什么是布隆过滤器：底层数据结构是bitmap，初始值都为0，当数据存在时，通过哈希运算获取三个索引值，将索引值设置为1。
   2. 数据进行查询时，会先经过布隆过滤器，如果布隆过滤器查询到的不存在三个1，则数据一定不存在，直接返回空。
   3. 可能存在误判，哈希冲突。

## 5.布隆过滤器的缺点

存在误判，哈希冲突

无法获取元素本身

很难删除元素（无法保证此位置是否存在其他元素，如果这个位置有哈希冲突）

## 7.Java 集合框架介绍一下，数据结构各自优缺点

Collection、Map，

List：有序，可以重复

Set：不可以重复

Queen：按特定的排队规则来确定先后顺序

Map：键值对

## 8.Hashset 和hashmap区别

底层数据结构：HashSet底层使用的是HashMap，使用的是Map的key来存储元素，保证元素的不重复。

1. **存储的内容**：
   - HashSet存储的是单个元素的集合，不允许重复元素。
   - HashMap存储的是键值对（key-value pair）的集合，每个键（key）唯一，但值（value）可以重复。
2. **内部实现**：
   - HashSet内部是基于HashMap实现的，实际上是通过HashMap的键来存储元素的，而值则被设为一个固定的对象（比如`Object`）。
   - HashMap通过哈希表实现，它使用键的哈希值来确定元素的存储位置，然后在该位置存储键值对。
3. **元素访问**：
   - HashSet不支持按照键来直接访问元素，只能通过迭代器或者增强for循环等方式来遍历集合中的元素。
   - HashMap可以通过键来直接访问对应的值，具有键值对之间的映射关系。
4. **性能和用途**：
   - HashSet适用于需要存储唯一元素集合的场景，对于判断某个元素是否存在于集合中，HashSet的查找性能更好。
   - HashMap适用于需要存储键值对的场景，可以通过键快速查找对应的值，适合需要根据键来进行数据检索或者映射的情况。

## 9.为什么 hashmap不是线程安全的

不安全；

结论：jdk1.7中，链表的插入是头插法，多线程操作时容易造成链表死循环。jdk1.8中，在putVal方法中，多线程操作会造成数据覆盖，体现在发生hash碰撞和++size时，hash碰撞导致数据被覆盖，++size导致链表长度少增加一个，导致数据覆盖。

https://blog.csdn.net/swpu_ocean/article/details/88917958?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171305467816800211585231%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171305467816800211585231&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88917958-null-null.142^v100^pc_search_result_base9&utm_term=HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8&spm=1018.2226.3001.4187

## 10.Concurrenthashmap底层结构

jdk1.7之间，使用分段锁

jdk1.8使用CAS和Synchorinze锁，在putVal方法中，判断哈希冲突时，如果没有发生冲突，使用CAS进行元素添加；产生哈希冲突时，使用synchronized锁来保证链表节点同步。

## 11.JVM 内存结构



![image-20240424120709585](./assets/image-20240424120709585.png)

1. 堆
2. 虚拟机栈
3. 本地方法栈
4. 程序计数器
5. 直接内存
6. 运行时常量池
7. 方法区：是一种概念，jdk1.7之前实现方法区的概念的是永久代，1.8之后，实现方法区概念的是元空间（本地内存）



1. **程序计数器（Program Counter Register）**：
   - 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在多线程环境下，每个线程都有自己独立的程序计数器，用于记录当前线程执行的位置。
2. **Java 虚拟机栈（Java Virtual Machine Stacks）**：
   - 每个线程在创建时会分配一个 Java 虚拟机栈，用于存储线程的方法调用栈和局部变量。每个方法被调用时，Java 虚拟机会创建一个栈帧（Stack Frame），用于存储方法的局部变量、操作数栈、方法返回值等信息。栈帧在方法调用结束后被销毁。
3. **本地方法栈（Native Method Stacks）**：
   - 本地方法栈类似于 Java 虚拟机栈，但它用于执行本地（Native）方法的调用。本地方法栈与 Java 虚拟机栈类似，但它们执行的是不同类型的方法调用。
4. **堆（Heap）**：
   - 堆是 Java 虚拟机中最大的一块内存区域，用于存储对象实例和数组对象。在堆中分配的内存由垃圾收集器（Garbage Collector）进行管理和回收。堆可以分为新生代和老年代，新生代又分为 Eden 区、Survivor 区（From 区和 To 区）。
5. **方法区（Method Area）**：
   - 方法区用于存储类的元数据信息、静态变量、常量池等数据。在 Java 8 之前，方法区也被称为永久代（Permanent Generation），但在 Java 8 中，永久代被元数据区（Metaspace）取代。元数据区是方法区的一部分，它用于存储类的元数据信息，具有更灵活的内存管理机制。
6. **运行时常量池（Runtime Constant Pool）**：
   - 运行时常量池是方法区的一部分，用于存储编译时生成的字面量（如字符串常量）、符号引用等信息。
7. **直接内存（Direct Memory）**：
   - 直接内存不是 Java 虚拟机的一部分，但它是 JVM 内存管理的一部分。直接内存是通过 Java NIO 中的 ByteBuffer 类来使用的，它允许 Java 程序直接访问本地内存，而无需经过 JVM 堆内存。

## 12.为什么 mysql 用索引查询就快?原理是?

1. **快速数据定位**: 索引是按照特定字段值排序的数据结构，例如 B-Tree 或哈希表。这样的数据结构可以帮助数据库引擎快速定位到符合查询条件的数据行，而不需要扫描整个表格。相比于全表扫描，索引查询可以在更短的时间内定位到需要的数据行。
2. **避免全表扫描**: 在没有索引的情况下，数据库系统可能需要对整个表格进行扫描来查找符合查询条件的数据。这种全表扫描的操作通常会消耗大量的时间和资源。而索引可以帮助数据库系统避免全表扫描，提高了查询效率。
3. **优化器选择最佳执行计划**: MySQL 的查询优化器会根据查询条件、索引信息以及表格统计信息等因素选择最佳的执行计划。在存在合适的索引时，优化器会倾向于选择使用索引来执行查询，从而提高查询的执行效率。



**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。**



## 13.Es 数据库和 mysal 索引区别 （不会

- Elasticsearch 的索引是基于倒排索引的，它将文档（行）中的每个字段进行索引，以便于快速进行全文搜索和匹配。倒排索引是一种将文档中的每个词映射到包含该词的所有文档的数据结构。
- ![image-20240425102628840](./assets/image-20240425102628840.png)
- MySQL 的索引通常是基于 B-Tree（平衡树）或哈希表等数据结构的，用于加速对数据库表中数据的检索。B-Tree 索引适用于范围查询、排序和分组等操作，而哈希索引适用于等值查询。



![image-20240504095841187](./assets/image-20240504095841187.png)

## 14.事务的理解

保证数据的安全性、一致性、完整性

## 15.事务四大特性

ACID

原子性

一致性

隔离性

持久性

## 16.事务隔离机制，可重复读的实现(答得不好

读未提交

读已提交

可重复读

串行化



不重复读一般不能解决幻读问题，但是在InnoDB存储引擎中可以解决幻读问题，只要归功于MVCC（Multi-Version Concurrency Control）多版本并发控制。

1. 读操作：快照读取，只会读取开启事务前的最新数据。
2. 写操作：当执行写操作时，会为数据行创建新的数据版本，旧版本仍然保留，供其他事务使用。
3. 版本回收：MVCC会定期进行版本的回收，删除不再需要的旧版本数据。
4. 一致性非锁定读：在更新数据时，加上版本号或者时间戳，当读取数据时，用当前可见的版本号与对应的数据的版本号进行对比，如果数据的版本号更加新，则表示数据不可见。
5. 锁定读：读取数据时，为数据加锁，防止数据被修改。



InnoDB对MVCC的实现

1. 隐藏字段：三个隐藏字段
   1. 最后一次操作数据行的事务id
   2. 指向undo log对应行的指针
   3. 如果没有设置主键且该表没有唯一非空索引，自动生成聚簇索引
2. Read Viem：保存对当前本事务不可见的其他活跃事务。
   1. 目前出现过的最大的事务ID+1，即下一个将被分配的事务ID，大于这个ID的数据版本不可见。
   2. 最小事务ID，小于这个id的数据版本都可见。
   3. 其他未提交的事务ID列表，后续即使它们修改了记录行的值，对于当前事务也是不可见的。
   4. 创建该Read View的事务ID。
3. undo log
   1. 事务回滚恢复数据。
   2. 当读取数据时，数据行被其他事务占用或者版本过高不可见，可以通过隐藏字段的回滚指针去undo log中读取旧版本的记录。



1. **版本号和回滚段**：InnoDB 使用了版本号和回滚段来实现 MVCC。每个数据行都会有一个隐藏的系统版本号，以及记录当前事务或者最近事务修改该行的版本号。同时，InnoDB 会维护一个回滚段，用于存储被删除或更新的行的旧版本。
2. **Read View**：在每个事务开始时，InnoDB 会为该事务创建一个 Read View（读视图）。Read View 包含了当前事务开始时数据库中所有活跃事务的版本号。这个版本号可以确保当前事务只能看到在它开始之前提交的数据。
3. **读操作**：当一个事务执行读操作时，它会使用自己创建的 Read View 来确定哪些数据是可见的。具体来说，对于每一行数据，InnoDB 会检查该行的版本号是否在当前事务的 Read View 范围内。如果该行的版本号在范围内，则表示该行对当前事务可见；否则，该行对当前事务不可见。
4. **写操作**：当一个事务执行写操作时，InnoDB 不会直接在原始数据行上进行修改，而是将修改的数据写入新的数据行，并更新数据行的版本号。同时，原始数据行的旧版本会被存储在回滚段中。这样做的好处是，读操作不会受到写操作的影响，因为读操作会使用自己创建的 Read View 来确定可见性。





# 美团二面

## 1.http和https区别

- 默认端口号：80和443
- URL前缀：http://和https://
- 安全性：http是采用明文形式，在tcp基础上通信；https采用ssl/tls协议对传输信息进行对称加密，秘钥采用非对称加密传输，也是建立在tcp基础上的。所以，https比http更加安全，但是同时消耗的服务器资源也更多。

## 2.tcp与udp区别

是否面向连接：TCP是面向连接的，需要先建立连接再进行信息的传输

是否有状态：TCP会记录自己发送消息的状态，比如消息是否发送，消息是否被接受。

是否传输可靠：TCP保证传输信息的可靠性

传输效率：TCP效率低

传输形式：TCP是基于字节，UDP基于报文

首部开销：TCP首部开销比UDP首部开销大

是否支持广播和多播形式：TCP只能点对点，UDP支持一对多，多对多，多对一。



UDP首部大小
UDP首部只有8个字节，其中包括：

源端口号：2个字节，用于标识发送端应用进程的端口号。
目的端口号：2个字节，用于标识接收端应用进程的端口号。
长度：2个字节，用于表示UDP数据报的总长度（包括首部和数据）。
校验和：2个字节，用于检测数据报在传输过程中是否出错。
TCP首部大小
相比之下，TCP的首部大小要大得多，通常为20个字节，但这只是一个基础大小。TCP首部还可能包含一些可选字段，这些字段可以增加首部的长度。TCP首部包括以下部分：

源端口号和目的端口号：各2个字节。
序列号：4个字节，用于标识数据报中的字节流的顺序。
确认号：4个字节，用于表示接收端期望接收的下一个字节的序列号。
数据偏移量：4位，用于表示TCP首部的长度。
保留：6位，通常设置为0。
标志位：6位，用于控制TCP连接的状态。
窗口大小：2个字节，用于流量控制。
校验和：2个字节。
紧急指针：2个字节，用于标识紧急数据的位置。
选项：可变长度，可能包含多种可选字段。
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/blog_programb/article/details/136872218

## 3.三次握手四次挥手

三次握手：

第一次握手：客户端发送SYN（连接标识位）、seq（数据），客户端处于syn-send状态。

第二次握手：服务端发送SYN（连接标识位）、ACK（信息标识位）、seq（我的数据）、ack（客户端seq+1)，服务端处于syn-receivce状态

第三次握手：客户端发送ACK（接受到了信息）、seq（客户端seq+1）、ack（服务端seq+1）



第一次握手：服务端确定客户端可以发送信息

第二次握手：客户端确定服务端可以发送信息、可以接收信息

第三次握手：服务端确定客户端可以接收信息

![image-20240427160958889](./assets/image-20240427160958889.png)

四次挥手：

第一次挥手：客户端发送FIN(seq = x)，说自己要关闭连接。

第二次挥手：服务端发送ACK(ack=x+1)，说我收到了你的请求。

第三次挥手：服务端发送FIN(seq=x)，说自己要关闭连接。

第四次挥手：客户端发送ACK(ack=x+1)，说我收到了你的请求。

![image-20240427162232190](./assets/image-20240427162232190.png)

第四次挥手时，客户端会等待2*mls时间再关闭连接，因为**MSL(Maximum Segment Lifetime)** : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html

## 4.说说事务四大特性 各个实现

原子性：一个事务中的操作要么全部成功要么全部失败。实现是MySQL的undo log回滚日志来实现，记录的是修改前的数据。

隔离性：各个事务之间相互不干扰。

一致性：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；

持久性：提交后的事务操作的数据会保存到磁盘中进行持久化。通过redo log日志来实现，操作的数据会放入内存中的bufferpool缓存，同时写入redo log日志文件，当事务提交后，会给redo log日志打上commit标记，当操作数据时主机不小心宕机，重启后，可以从redo log中恢复已经操作成功的数据。

## 5.mysql隔离级别有哪些

读未提交

读已提交

可重复读

串行化

## 6.默认的是哪一个 仍然可能面临什么问题 为什么

可重复读；

仍然可能面临幻读，因为读取数据有快照读和当前读，进行当前读时，像select lock in share mode(共享锁), select for update(排他锁); update, insert ,delete这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/godloveleo9527/article/details/109554263

## 7. 脏读幻读区别

脏读：事务A读取到了事务B没有提交的数据；

幻读：事务A条件查询时，刚开始查询到了3条数据，此时事务B新增了几条数据，然后事务A再次查询时，查询到了事务B新增的数据。

## 8.对于springboot的理解 常用注解

简化Spring配置开发， 自动装配。

@SpringBootApplication注解底层有：

- @SpringBootConfiguration：运行在spring上下文注册其他bean或者导入其他配置
- @EnableConfiguration：自动装配
- @ComponentScan：扫描需要进入spring容器的bean



自动装配原理：

- 主要是@EnableConfiguration注解，这个注解主要是导入了AutoConfigurationImportSelector
- AutoConfigurationImportSelector类中的selectImports方法StringUtils.toStringArray(autoConfigurationEntry.getConfigurations())，获取全部符合条件类的全类名。
- selectorImports方法中调用本类中的getAutoConfigurationEntry(annotationMetadata)方法来获取需要的所有类
- getAutoConfigurationEntry方法，首先判断是否开启自动注解，第二步会获取@SpringBootApplication注解上的exclude和excludeName属性，第三步获取需要所有需要装配的配置类，读取`META-INF/spring.factories`文件的内容并放入configurations中，第四步，进行按需加载，排除不需要的配置类





1. `@SpringBootApplication`: 用于标识 Spring Boot 应用的主类，通常放在项目的入口类上。
2. `@Controller`: 将类标记为 Spring MVC 控制器。
3. `@RestController`: 结合了 `@Controller` 和 `@ResponseBody`，用于创建 RESTful 的控制器。
4. `@Service`: 标识为业务逻辑层的组件。
5. `@Repository`: 标识为数据访问层的组件，通常用于数据库操作。
6. `@Autowired`: 自动装配，用于自动注入 Spring 容器中的 Bean。
7. `@Component`: 通用的组件注解，用于标识任意一个类作为 Spring 组件。
8. `@Configuration`: 声明一个类作为配置类，通常配合 `@Bean` 使用。
9. `@RequestMapping`: 将 HTTP 请求映射到控制器的处理方法上，可以用于类级别和方法级别。
10. `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`: 简化了 `@RequestMapping` 的写法，分别对应 HTTP 的 GET、POST、PUT 和 DELETE 请求。

## 9.AOP使用 对底层的了解

什么是AOP?AOP的底层实现
1.什么是AOP
AOP（Aspect Oritented Programing） 面向切面编程。
AOP采取横向抽取机制，取代了传统的继承纵向继承体系的重复性代码（性能监视，事务管理，安全检查，缓存）。
Spring的AOP采用了纯java实现，不需要专门的编译过程和类加载器，在运行期间通过动态代理的方式向目标类注入增强代码。

2.AOP应用场景说明
对程序进行增强:不修改源码的情况下.
权限校验,日志记录,性能监控,事务控制.

3.AOP的底层实现
采取代理机制：
Spring的AOP的底层用到了两种代理机制：
JDK的动态代理：针对实现接口的类产生代理
Cglib的动态代理：针对没有实现接口的类产生代理

什么是动态代理

:代理是一种设计模式，提供了目标对目标对象的的访问方式：即是通过代理对象访问目标对象：可以再目标对象的基础上，增强额外的功能，拓展目标对象的功能。
这里用到的编程思想：不要随意去别人已经写好的代码或者方法，如需修改，可以使用代理的方式来扩展该方法

举个例子说明代理的作用：假如我们想邀请以为明星，那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子
4.代理模式的分类
1.静态代理 —装饰者模式
2.动态代理：a .JDK的动态代理
b .Cglib的动态代理
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/dpf373521/article/details/95459786

## 10.创建索引需要注意什么？

- 对于where order by group b y的字段作为索引
- 尽量使用联合索引
- 单表索引不要超过5个
- 对于经常更新的字段不要建立索引
- 

## 11.索引失效场景

- 索引列有计算
- 索引列使用函数
- 违反最左匹配原则
- 使用like模糊查询时%在左边
- 字段类型不同，字符类型的字段，使用数字
- 使用or时，两边的字段有一个不为索引列
- 使用not in和not exist时

## 12.聚簇索引和非聚簇索引区别

聚簇索引：非叶子节点存放索引，叶子节点存放索引和数据

非聚簇索引：叶子节点保存的是主键



**优点**：

- **查询速度非常快**：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。
- **对排序查找和范围查找优化**：聚簇索引对于主键的排序查找和范围查找速度非常快。

**缺点**：

- **依赖于有序的数据**：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
- **更新代价大**：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。



**优点**：

更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。

**缺点**：

- **依赖于有序的数据**:跟聚簇索引一样，非聚簇索引也依赖于有序的数据
- **可能会二次查询(回表)**:这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/database/mysql/mysql-index.html

## 13.各类垃圾回收算法以及优缺点

1. **标记-清除算法（Mark-Sweep）**：
   - **工作原理**：首先，它会标记所有活动对象，然后清除未标记的对象。
   - 优点
     - 简单直观，易于实现。
     - 不需要移动对象，适用于大型和长期运行的应用程序。
   - 缺点
     - 内存碎片化问题：清除后会留下不连续的内存块，可能导致分配大对象时无法找到足够的连续内存空间。
     - 垃圾回收时会暂停应用程序，可能导致长时间的停顿。
2. **复制算法（Copying）**：
   - **工作原理**：将堆分为两个区域，每次只使用其中一个。在垃圾回收时，将存活对象从一个区域复制到另一个区域，然后清除整个区域。
   - 优点
     - 没有内存碎片化问题，分配对象时更快速。
     - 内存分配连续性好，减少了内存分配的时间。
   - 缺点
     - 浪费一半的内存空间，可能不适合大型对象或长期运行的应用程序。
     - 需要额外的复制操作，可能影响性能。
3. **标记-整理算法（Mark-Compact）**：
   - **工作原理**：与标记-清除算法类似，但在清除之后，会将存活对象移动到内存的一端，以减少内存碎片化问题。
   - 优点
     - 解决了标记-清除算法的内存碎片化问题。
     - 没有复制算法的内存浪费。
   - 缺点
     - 需要额外的内存空间来进行移动对象，可能导致垃圾回收时的停顿。
4. **增量式垃圾回收算法（Incremental Garbage Collection）**：
   - **工作原理**：将垃圾回收过程分成多个阶段，每个阶段执行一小部分工作，然后让应用程序执行一段时间。
   - 优点
     - 减少了应用程序的停顿时间，提高了响应性。
   - 缺点
     - **实现复杂**，增加了垃圾回收器的开销。
     - 可能会导致垃圾回收的频繁执行。
5. **分代垃圾回收算法（Generational Garbage Collection）**：
   - **工作原理**：根据对象的生命周期将堆分成不同的代，一般分为新生代和老年代。新创建的对象首先放入新生代，经过多次垃圾回收后，仍然存活的对象会被移动到老年代。
   - 优点
     - 大多数对象都具有短生命周期，因此在新生代进行垃圾回收可以更快速地回收大部分对象。
     - 老年代的垃圾回收频率较低，减少了全堆垃圾回收的停顿时间。
   - 缺点
     - 对象的晋升和老年代的垃圾回收可能会引入停顿时间。



# 中国航信嘉兴 Java实习

## 1.Mybatis-Plus 有几种方式可以写 SQL?

- xml文件中编写语句
- 在接口上面使用@Select(语句)
- 使用Wrapper方式，例如QueryWrapper.eq等

## 2.你了解那个双亲委派机制吗？

https://blog.csdn.net/qq_43911324/article/details/122652641?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171437706916800225579992%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171437706916800225579992&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122652641-null-null.142^v100^pc_search_result_base9&utm_term=%E5%8F%8C%E6%B8%85%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187

双亲委派机制是JVM进行类加载时的机制，JVM是加载类是按需加载的，采用双亲委派机制，对于一个自定义类，默认是使用Application ClassLoader，然后会委派父亲加载器（一直向上委派直到Bootstrap ClassLoader）。采用双亲委派机制可以防止Java核心类库被破坏和防止类重复加载。

![image-20240429164331628](./assets/image-20240429164331628.png)



## 3.MySQL的事务

MySQL的事务，一言蔽之，一组操作要么全部成功，要么全部失败。保证数据的完整性、一致性、安全性。

## 4.并发事务会带来一些什么问题？

脏读

幻读

不可重复读

丢失修改

## 5.Spring里面用过的设计模式？

oj项目主要使用到了三个设计模式，



工厂模式，

判题服务调用代码沙箱，一个通用的代码沙箱接口，实现类为各种类型的代码沙箱，代码沙箱（示例代码沙箱、远程代码沙箱、第三方代码沙箱），具体选择哪个，可以传入一个type参数，然后用if else的思想去调用；工厂模式相当于定义一个通用的工厂类来生产不同类型的代码沙箱，具体实现为提供一个静态方法（参数为type)，根据type返回对应的代码沙箱实例，type参数可以在yml文件中配置，使用@value引入；



代理模式，

日志功能必不可少，我们通常做法是，在每个代码沙箱的实现类里面，去打上日志，如果日志功能复杂的话，导致代码重复率高；代理模式，相当于定义一个代码沙箱的代理类去实现通用的日志输出功能，具体实现为代理类实现代码沙箱接口，构造函数参数为代码沙箱接口，调用被代理的接口实现类，在前后增加日志功能，**之前是代码沙箱实例去调用代码沙箱，现在是使用代理类去调用代理类中的方法（参数为代码实现实例），方法实现日志功能和调用代码沙箱；**



策略模式，

接收到代码沙箱返回的结果，然后进行一些逻辑的判断，此时，对于不同的语言可能会有不同的判断逻辑，如果把所有逻辑都使用if else思路实现的话，在判题业务流程中，会使代码冗余，不美观。策略模式，定义一个通用的判题策略接口，不同语言的判题策略都实现该接口的判题方法（自己的逻辑）；然而，具体需要使用哪个策略的时候，需要用if else来判断，这个判断逻辑使用一个策略管理类来实现，策略管理类里面去判断策略类型，去调用具体的策略；



这里使用的三种设计模式，都是体现了面向对象的封装特性，对类进行层层封装。





## 6.如果有一个Person类，里面有一个字段叫做创建时间。我现在想对这一堆的人进行去重并排序，如果是你的话是怎么来处理排序的话是按照这个创建时间的进行排序，进行一个倒序？

distinct关键字确保字段出现去重

order by desc降序





# Spring专题

## 1.Spring是如何简化开发的？

- 基于POJO的轻量级和最小侵入化编程
  - POJO是bean，轻量级编程指使用简单的bean对象来实现业务逻辑的开发，最小侵入化编程指的是不依赖特定的框架和技术。
- 通过依赖注入和面向接口实现松耦合
  - DI，将bean交给IOC容器管理，实现bean之间的依赖关系注入；面向接口编程便于代码的扩展。
- 基于切面和惯例进行声明式编程
  - 主要是指@Transactional声明式事务，不用手动开启事务。
- 通过切面和模版减少样板式代码
  - 结合切面和模版可以将通用代码提取出来，使得代码更加简洁和可维护。例如日志开发。

## 2.谈谈你对Spring的理解

Spring是一个开源的、轻量级、用于构建企业应用开发的框架。核心在于IOC和AOP，

IOC：控制反转是一种思想，依赖注入DI是对IOC思想的实现。

AOP：面向切面编程，降低代码之间的耦合度，简化代码，减少重复代码。

Spring是一个框架、一个容器、是一种生态！

## 3.Spring的核心

Spring是一个开源框架，

Spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。

Spring是一个IOC和AOP的容器框架。

- IOC：控制反转
- AOP：面向切面编程
- 容器：包含并管理应用对象的生命周期，就好比桶装水，spring类似桶，对象就是水。



## 4.Spring的事务传播机制是什么？

多个事务相互调用时，事务的传播机制保证事务的正常执行：

![image-20240501231745385](./assets/image-20240501231745385.png)

## 5.Spring框架中的单例Bean是线程安全的吗？

Spring容器初始化时会为单例bean创建一个实例，如果bean是无状态的，例如controller、service等，则不存在线程安全问题，如果是有状态的例如实例变量，则存在线程安全问题。



如何解决？

使用Synchronized锁（不推荐），使用ThreadLocal把变量编程线程私有



## 6.Spring框架中使用了哪些设计模式和应用场景？

 

1. **工厂模式（Factory Pattern）**：
   - 应用场景：Spring 使用工厂模式来管理 Bean 对象的创建，通过 BeanFactory 或者 ApplicationContext 创建和管理 Bean 实例。
   - 设计模式：主要应用了工厂方法模式和抽象工厂模式。
2. **单例模式（Singleton Pattern）**：
   - 应用场景：Spring 中的 Bean 默认是单例的，确保一个 Bean 在应用程序中只有一个实例。
   - 设计模式：采用了单例模式来保证 Bean 的唯一性。
3. **模板模式（Template Pattern）**：
   - 应用场景：Spring 提供了一系列的模板类，如 JdbcTemplate、RestTemplate 等，用于简化开发者在特定场景下的操作流程。
   - 设计模式：这些模板类采用了模板模式，将通用的操作流程封装在模板方法中，具体的实现交由子类完成。
4. **代理模式（Proxy Pattern）**：
   - 应用场景：Spring AOP（面向切面编程）中使用代理模式来实现横切关注点（cross-cutting concerns）的模块化。
   - 设计模式：采用了动态代理来在运行时创建代理对象，实现横切逻辑的织入。
5. **适配器模式（Adapter Pattern）**：
   - 应用场景：Spring MVC 中的 HandlerAdapter 将不同类型的请求适配到不同的处理器进行处理。
   - 设计模式：使用了适配器模式来使得不同类型的请求与不同类型的处理器能够协同工作。
6. **策略模式**：加载资源文件的方式，使用了不同的方法，比如：ClassPathResource，FileSystemResource、ServletContextResource，UrlResource，它们都有共同的接口Resource；在AOP的实现中，采用了两种不同的方式，JDK动态代理和CGLIB代理。
7. **责任链模式（Chain of Responsibility Pattern）**：
   - 应用场景：Spring Security 中的过滤器链（Filter Chain）将请求依次传递给一系列的过滤器进行处理。
   - 设计模式：使用了责任链模式来实现请求的处理链。

![image-20240501233622942](./assets/image-20240501233622942.png)

## 7.Spring事务的隔离级别有哪些？

即数据库的隔离级别，

在进行配置的时候，如果数据库和Spring代码中的隔离级别不同，那么以Spring的配置为主。



## 8.Spring事务的实现方式原理是什么？

两种，一种是编程式事务，一种是声明式事务；

编程式事务是手动开启，手动提交，手动回滚，例如TransactionTemplate；



声明式事务是@Transactional注解实现，是AOP面向切面编程的体现，

当一个方法被 `@Transactional` 注解修饰时，Spring 将会为这个方法创建一个代理对象，这个代理对象会拦截方法的调用，在方法执行前开启事务，在方法执行后根据方法执行情况决定是提交事务还是回滚事务。

## 9.Spring事务什么时候会失效？

- 方法的修饰符不是public
- bean对象没有被Spring容器管理
- 数据库不支持事务：MySQL5.7之间
- 数据源没有配置事务管理器：SpringBoot只需要配置对应的spring.datasource，Spring需要配置。
- 自身调用问题：当前类里面的方法调用加了事务注解的方法，该方法的事务不会生效。
- 异常被捕获：自己在事务方法里面catch了异常
- 异常类型错误或者配置错误：在注解里设置rollbackException=NPE，但是实际出现的异常是其他异常。



## 10.Spring支持的bean作用域有哪些？

- **singletion**：单例bean，IOC容器只会创建一个bean实例，每次返回的也是同一个实例。
- **prototype**：多例bean，IOC容器会创建多个bean实例，每次返回的都是一个新的实例。
- **Request：** 在 Web 应用中，每个 HTTP 请求都会创建一个新的 Bean 实例，并且在该请求范围内共享。
- **Session：** 在 Web 应用中，每个 HTTP Session 都会创建一个新的 Bean 实例，并且在该 Session 范围内共享。
- **Application：** 在 Web 应用中，每个 ServletContext 都会创建一个新的 Bean 实例，并且在整个 Web 应用范围内共享。
- **WebSocket：** 在 WebSocket 应用中，每个 WebSocket 连接都会创建一个新的 Bean 实例，并且在该 WebSocket 连接范围内共享。



## 11.Spring的bean的声明周期

实例化----属性赋值（依赖注入）----初始化----bean使用----bean销毁



详解初始化：

1. 检查Aware接口的实现情况：Spring允许bean实现ApplicationContextAware接口实现对applicationContext的赋值，beanName赋值等
2. 执行BeanPostProcessor接口的postProcessBeforeInitialization方法
3. 执行init-method方法（增加了@PostConstruct注解的方法）
4. 执行InitialzingBean接口中的afterPropertiesSet方法
5. 执行BeanPostProcessor接口的postProcessAfterInitialization方法



bean销毁详解：

1. 在bean使用前注册销毁回调接口
2. 在bean使用后，执行DisposableBean接口的Destory方法
3. 执行destory-method（注解了@PreDestory）





属性赋值之后，对bean进行一些额外的初始化操作：在 Bean 实例化和依赖注入完成后，Spring 容器会调用 Bean 的初始化方法。有两种主要的方式来指定初始化方法：

- 使用 `@PostConstruct` 注解：在 Bean 类的初始化方法上添加 `@PostConstruct` 注解，Spring 容器会在依赖注入完成后立即调用这个方法。
- 实现 `InitializingBean` 接口：在 Bean 类中实现 `InitializingBean` 接口，并重写其中的 `afterPropertiesSet()` 方法，在依赖注入完成后，Spring 容器会调用这个方法。





处理初始化回调： 在执行 Bean 的初始化方法之后，Spring 容器会调用注册的初始化回调。这些回调可以是 `BeanPostProcessor` 接口的实现类中定义的方法。`BeanPostProcessor` 接口包括 `postProcessBeforeInitialization()` 和 `postProcessAfterInitialization()` 两个方法，分别在 Bean 初始化方法执行之前和之后调用。

`postProcessBeforeInitialization()` 方法允许在 Bean 的初始化方法执行之前对 Bean 进行额外的自定义处理，而 `postProcessAfterInitialization()` 方法允许在 Bean 的初始化方法执行之后对 Bean 进行进一步处理。

例如：

```java
javaCopy codepublic class MyBeanPostProcessor implements BeanPostProcessor {
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        // 在初始化方法执行之前对 Bean 进行处理
        return bean;
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        // 在初始化方法执行之后对 Bean 进行处理
        return bean;
    }
}
```



## -----------------------------------------------

## 1.如何实现一个IOC容器

1. 先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象
2. 进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中‘
3. 容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作
4. 进行对象的初始化操作，也就是给类中的对应属性值进行设置，也就是依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中
5. 通过容器对象来获取对象，进行对象的获取和逻辑处理工作
6. 提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁



1. **准备容器对象：** 在容器启动之初，会准备一个容器对象，其中包含了用于存储BeanDefinition对象的数据结构，通常使用Map来存储，以便后续注册、获取和管理Bean。
2. **配置文件读取或注解解析：** Spring会读取配置文件或者解析注解，将Bean的定义信息封装成BeanDefinition对象，并存储到容器中。这些BeanDefinition对象包含了Bean的类型、作用域、依赖关系等信息。
3. **实例化Bean：** 容器根据BeanDefinition对象中的信息，通过反射机制实例化Bean对象。这个过程涉及到类的加载、实例化和构造函数的调用。
4. **依赖注入：** 在实例化Bean之后，容器会进行依赖注入，将其他Bean所需的依赖注入到当前Bean中。这个过程可以通过构造函数注入、Setter方法注入或者字段注入来实现。
5. **获取对象：** 容器提供了一系列的方法来获取Bean对象，开发者可以通过容器对象来获取已经创建好的Bean，以便进行后续的业务逻辑处理。
6. **销毁操作：** 当Bean不再被需要或者容器关闭时，容器会负责销毁Bean对象，释放资源。通常这个过程包括调用Bean的销毁方法（如果有定义的话）以及释放Bean占用的资源等操作。

## 2.什么是嵌入式服务器，为什么使用嵌入式服务器？

Spring项目的启动需要放在tomcat服务器上，而SpringBoot框架中内置了tomcat.jar包，启动SpringBoot项目无需进行额外操作；嵌入式服务器简化了项目启动流程，达到一键开发部署的目的；



## 3.说一下使用Spring的优势

- 轻量级和最小化侵入：基于POJO的轻量级和最小侵入化编程
- IOC和DI：控制反转和依赖注入，降低了组件之间的耦合度，提高了代码的灵活性和可扩展性。
- AOP：通过切面和模版减少样板式代码，降低了代码的重复性
- 声明式事务管理：通过简单配置来管理事务，大大简化了事务管理的流程。
- **灵活的组件集成**：Spring提供了丰富的组件集成功能，例如对ORM框架的基础，Web框架的集成等等。
- **高度开放性**：Spring框架采用模块化的设计，各个模块之间高度解耦，开发者可自由选用Spring框架的部分或全部。
- **丰富的生态系统和社区支持**



## 4.说说你对AOP的理解

AOP面向切面编程，能够将与业务无关，却为业务模块所共同调用的代码（例如事务处理、日志管理、权限控制等）封装起来，减少重复代码，**降低模块间的耦合**度，便于代码的扩展和维护。



Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，AOP就会使用JDK Proxy，去创建代理对象；如果没有实现接口，则会使用Cglib生成一个被代理的对象的子类来作为代理。



AOP切面设计的术语：

- 目标Target：被通知的对象
- 代理Proxy：创建的代理对象
- 连接点JoinPoint：被代理的对象所属类中的所有方法
- 切入点PointCut：被切面拦截/增强的连接点
- 通知：增强的逻辑/代码，拦截到目标对象的连接点之后要做的事情
- 切面：切入点+通知
- 织入Weaving：将通知应用到目标对象，进而生成代理对象的过程动作



## 5.说说你对IOC的理解

IOC控制反转，是一种设计思想，在Spring中的具体实现是IOC容器；

控制即，对象的创建等操作，反转是指将这些操作交给外部Spring容器来管理；

将对象之间的相互依赖关系交给IOC容器来管理，并由IOC容器完成对象的注入，这样在很大程度上可以简化代码，**把应用从复杂的依赖关系中解放出来**。IOC容器就像一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何创建出来的。

在Spring中，IOC容器是Spring用来实现IOC的载体，IOC容器实际上一个Map，Map中存放的是各种对象。



## -----------------------------------------------

## 1.说说自己对SpringMVC的了解？

MVC，Model、View、Controller，通过模型、视图、控制层将数据、页面、业务逻辑分离



Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。



答：
 一种轻量级的、基于MVC的Web层应用框架。通过把模型-视图-控制器分离，将web层进行职责解耦，简化开发。

 **spring MVC是一种分层设计思想，目标是将复杂的应用系统按照分层处理进行设计和规划,通过这种设计方式达到分而治之的效果,从而降低程序开发的难度,提高代码的可维护性.**Spring MVC核心类是 DispatcherServlet，它是一个 Servlet，顶层是实现的Servlet接口。



一种轻量级、基于MVC的web层应用框架，通过模型-视图、控制器分离，将复杂的web应用程序分层设计，达到分而治之的效果，降低了程序开发难度，提高了代码可维护性。



题外：
什么是MVC
mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。

mvc设计模式的好处

1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。

2.有利于系统的并行开发，提升开发效率。
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/ABCQHC/article/details/106675206

## 2.SpringMVC的核心组件有哪些？

1. DispatcherServlet：核心的中央处理器，负责接收请求、分发，并给予客户端响应。
2. HandlerMapping：处理器映射器，根据url去匹配查找能处理的Handler，并会将请求涉及到的拦截器和Handler一起封装。
3. HandlerAdapter：处理器适配器，根据HandlerMapping找到的Handler，适配执行对应的Handler。
4. Handler：请求处理器，处理实际请求的处理器。
5. ViewResolver：视图解析器，根据Handler返回的逻辑视图，，解析并渲染真正的视图，并传递给DispatcherServlet响应客户端。



## 3.SpringMVC的工作原理了解吗？

1. 浏览器发送请求，DispatcherServlet拦截请求。
2. DispatcherServlet根据请求信息调用HandlerMapping。HandlerMapping根据URL去匹配查找能处理的Handler（Controller控制器），并会将请求涉及到的拦截器和Handler一起封装。
3. DispatcherServlet调用HandlerAdapter适配器执行Handler。
4. Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型和相应的视图信息。Model是返回的数据对象，View是个逻辑上的视图。
5. ViewResolver会根据逻辑view查找实际的view。
6. DispatcherServlet把返回的Model传给View(视图渲染)。
7. 把view返回给浏览器。



## 4.统一异常处理怎么做？





















# Java基础专题

## 1.Java语言有哪些特点？

- 简单易学
- 面向对象（封装、继承、多态）
- 编译与解释并存
- 平台无关性（因为JVM虚拟机）
- 支持多线程（C++不支持多线程）
- 可靠性（自动内存回收，异常处理）
- 安全性（访问权限修饰符）

## 2.Java SE 和 Java EE

Java SE是基础版本，没有前端页面开发，没有数据库连接；

Java EE是高级版本，企业级应用程序和Web程序开发。



## 3. JVM JDK JRE

JVM：Java虚拟机，Windows Linux Mac上都有不同实现，目的是相同的class文件都会有相同的结果，是一次编译，随处运行的关键。

JRE：Java运行时环境，包括JVM，Java基础类库

JDK：Java开发工具包，包含了JRE，同时包含了java源码的编译器javac以及一些其他工具javadoc文档注释工具、javap反编译工具等



## 4.什么是字节码？采用字节码的好处？

字节码文件是.class文件，是Java源码编译后的文件形式，是JVM虚拟机识别的文件。



好处：字节码不针对某种机器，Java语言可以移植；Java语言执行效率提高。



## 5.为什么说Java语言编译与解释并存

因为Java源码首先要经过编译器编译成字节码文件，再由JVM虚拟机解释成机器码。



## 6.AOT有什么优点？为什么不全部使用AOT呢？

是什么：在程序执行前提前编译成机器码，属于静态编译（C++ 、C、Go语言），编译成机器码



优点：

- 避免了JIT预热的开销，提高程序启动速度
- 减少内存占用
- AOT编译后的代码不容易被反编译和修改，增强程序安全性



为什么不全部使用？

- AOT不支持反射、动态代理、动态加载等动态特性



## 7.Java 和 C++的区别

- Java不提供指针直接访问内存，程序内存更安全
- Java的类是单继承，接口可以多继承，C++支持多继承。
- Java有自动内存管理机制
- Java不支持操作符重载，只支持方法重载。



## 8.标识符和关键字的区别

标识符：变量名、类名



关键字：public  static final 等



## 9.Java的基本数据类型



int：32位

long：64位

float：32位

double：64位

short：16位

byte：8位

boolean：1位

char：16位



## 10.基本类型和包装类型的区别？

用途：包装类型可以用于泛型

存储方式：包装类型放在堆中；基本类型的局部变量放在栈中，成员对象放在堆中。

占用空间：包装类型大。

默认值：成员变量包装类型默认为null，基本数据类型有默认值且不是null。

比较方式：包装类型==比较的是内存地址，比较值需要使用equals方法。



## 11.包装类型的缓存机制

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。



## 12.自动装箱与自动拆箱的原理

装箱：调用了包装类的valueOf方法



拆箱：调用Integer x ; x.intValue方法



## 13.为什么浮点数运算的时候会有精度丢失的问题？

计算机保存二进制数有宽度限制，对于浮点数只能截断存储。



如何解决？

通过BigDecimal实现浮点数的运行，不会造成精度丢失。



## 14.超过long整型的数据应该如何表示？

使用BigInteger类型，内部使用int[]数组存储。

## -----------------------------------------------

## 1.成员变量与局部变量的区别

语法形式：成员变量可以被访问修饰符修饰，局部变量不可以。

存储方式：成员变量，反之存储在堆中，局部变量存储在栈中（局部变量表）。

生存时间：成员变量随着对象的销毁而销毁，局部变量随着方法的调用结束而销毁。

默认值：成员变量有默认值（因为成员变量有可能运行时赋值，如果报错没有默认值会影响用户体验），局部变量需要手动赋值。



## 2.静态变量有什么作用

静态变量是被static修饰的变量，可以被类的所有实例共享，节省内存。



## 3.字符型常量和字符串常量的区别

形式：单引号，双引号

含义：字符常量相当于一个整数值（ASCII值），可以参与表达式运算；字符串常量代表一个地址值

占内存大小：字符常量只占2个字节。



## 4.静态方法为什么不能调用非静态成员

- 静态方法是属于类的，在类加载的时候就会分配内存；而非静态成员属于实例，只有在类实例化之后才存在。
- 在非静态成员不存在的时候静态方法已经存在，这个时候静态方法无法调用非静态成员。



## 5.静态方法和实例方法的区别

- 调用方式：类名.静态方法名，类实例.实例方法名
- 访问类成员是否存在限制：静态方法是运行访问静态成员变量



## 6.重载和重写的区别

重载：方法名相同，参数类型、参数个数不同

重写：什么都相同，实现不同。



## --------------------------------------------------

## 1.面向对象和面向过程的区别

面向过程把解决问题的过程拆成一个方法个，通过方法的执行去解决问题。

面向对象是先抽象出对象，然后用对象执行方法的方式解决问题。



## 2.创建一个对象用什么运算符？对象实例与对象引用有何不同？

new ；

- 对象实例存放在堆里面，对象引用存放在栈内存里面。
- 一个对象实例可以有很多引用，一个引用可以指向0或1个对象实例。



## 3.对象的相等和引用相等的区别？

对象的相等比较的是内存中存放的内容是否相等；

引用相等比较的是它们指向的内存地址是否相等；



## 4.构造方法有哪些特点？是否可以被override？

特点：

- 名字与类名相同。
- 没有返回值，但不能用void。
- 生成类对象时自动执行。



不能被override，但是可以overload。



## 5.面向对象三大特征

1. 封装：
   1. 封装是把一个对象的**状态信息**（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是提供一些可以被外界访问的方式来操作属性。（空调、空调遥控器的例子）
2. 继承：
   1. 不同类型的对象，有共同的点，将共同的方法抽离出来，作为父类。子类继承父类的所有方法和属性，但是无法访问父类的私有属性和方法，只是拥有。子类可以用自己的方式实现父类的方法。
3. 多态：
   1. 父类的引用指向子类的实例，接口与实现类。
   2. 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。



## 6.接口和抽象类的共同点和区别？

共同点：

1. 都不能被实例化。
2. 都可以包含抽象方法。
3. 都可以有默认实现的方法（Java 8可以用default关键字在接口中定义默认方法）



区别：

1. 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用（子类继承抽象父类中的非抽象方法），强调的是所属关系。
2. 一个类只能继承一个类，但是可以实现多个接口
3. 接口中的成员变量默认是public static final，抽象类的成员变量默认为default（同一个包内可见），可以在子类中被重新定义，也可以被重新赋值。





## 7.深拷贝和浅拷贝的区别

浅拷贝：浅拷贝会在堆上创建一个新对象，如果对象内部属性有引用数据，则会复制内部对象的引用地址。

深拷贝：完全复制整个对象。

引用拷贝：两个引用指向同一个对象。



## 8.==和equals的区别

==对于基本类型是比较值，对于引用类型比较的是内存地址值。

而equals不能比较基本数据类型，对于对象，如果没有重写，则比较的是内存地址值，如果重写了equals方法，一般比较的是对象的属性值。



## 9.为什么重写equals方法时必须重写hashCode

因为两个相等的对象的哈希值也必须相等；如果只重写了equals，例如HashSet存储元素时，两个equals相等的对象存储的位置不同，违反了hashSet元素不重复的特点，



## 10.String、StringBuffer、StringBuilder的区别

可变性：String底层是private final char数组，不可变；后面两个都提供了方法来修改char数组。

线程安全性：String中的对象不可变，理解为常量不存在线程安全问题；StringBuffer的操作用了synchronized锁，StringBuilder存在线程安全问题。

性能：String进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。后面两者都是对对象本身进行操作，而StringBuilder的性能稍高但是存在线程安全问题。



## --------------------------------------------------------------

## 1.String.equals和Object.equals的区别？

String的equals是被重写过的，比较的是字符串的值是否相等



## 2.字符串常量池的作用了解吗？

字符串常量池是JVM为了提升性能和减少内存消耗针对String类专门开辟的一块区域，主要是为了避免字符串的重复创建。



## 3.String s1 = new String("abc")创建了几个字符串对象？

1个或者2个；

如果字符串常量池里面不存在字符串abc的引用，则会在堆上创建两个字符串对象，其中一个字符串对象的引用会保存在字符串常量池中。

如果字符串常量池里面存在字符串abc的引用，则会在堆上创建一个字符串对象abc。



## 4.String.intern方法有什么作用？

是一个native方法，

- 如果该字符串在常量池中有引用，则直接返回字符串在字符串常量池中的引用；
- 反之，在字符串常量池中创建一个指向该字符串对象的引用并返回。



## 5.String类型的变量和常量做+运算时发生了什么？

常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。

对于 `String str3 = "str" + "ing";` 编译器会给你优化成 `String str3 = "string";` 。

并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：

- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。
- `final` 修饰的基本数据类型和字符串变量
- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）

**引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/java/basis/java-basic-questions-02.html





## 6.Exception和Error的区别？

Exception：程序本身可以处理的异常，可以通过catch来进行捕获。分为Checked Exception（受检查异常，必须处理）和Unchecked Exception（可以不处理）。

Error：错误，程序无法处理的错误，这些异常发生时，JVM一般会选择线程终止。



## 7.checked exception和unchecked exception的区别？

Checked Exception：受检查异常，Java代码在编译过程中，必须要进行catch或者throws，否则无法编译；除了RuntimeException及其子类外。IO异常、ClassNotFoundException等



Unchecked Exception：在代码中不进行处理，也能进行编译；NPE、NumberFormatException等



## 8. Throwable类常用方法有哪些？

**getMessage()：返回异常的简要描述；**

toString（）：返回异常的详细信息；

printStackTrace：在控制台上打印异常信息；

getLocalizedMessage：如果Throwable子类覆盖了这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则返回的内容与getMessage相同。



## 9. try-catch-finally如何使用？

- 如果没有catch块，则必须要有finally块
- 无论异常是否被捕获，finally里的语句都会被执行，在try和catch的return执行前，会先执行finally里面的语句。
- 如果finally里面有return，则会覆盖try语句里面的return



## 10.finally里面的语句一定会执行吗？

不一定；

1. 当finally之前，虚拟机被终止运行：System.exit(1)
2. 程序所在的线程死亡；
3. 关闭CPU；



## 11.如何使用try-with-resources代替try-catch-finally？

面对需要关闭的资源，我们应该优先使用前者。前者会自动关闭资源。



## --------------------------------------------

## 1.什么是反射？

反射是一个框架的灵魂，让我们能够在**运行时分析类并执行类中的方法**；

通过反射让我们**能够获取任意一个类的方法和属性，并调用这些方法和属性**；



## 2.反射的应用场景了解么？

动态代理、注解都用到反射了，Spring、Mybatis等框架



## 3.谈谈反射的优缺点

优点：代码更加灵活，是框架开箱即用的核心所在。

缺点：安全问题、性能问题；



## 4.获取Class对象的四种方法？

1. TargetObject.class
2. Class.forName(全类名)
3. targetObject.getClass()
4. 类加载器（ClassLoader.getSystemClassLoader.loadClass(全类名)），不会进行初始化，即静态方法不会执行；



## 5.反射的基本操作？

1. 获取Class对象,class
2. 实例化，class.newInstance()，targetObject
3. 获取方法，targetObject.getDeclareMethods()，getDeclareMethod(方法名，方法参数类型)；
4. method.invoke（实例，"参数"）执行方法
5. 获取属性，getDeclareField(属性名)



## 6.什么是SPI？

Service Provider Interface：服务提供方提供接口，服务实现方提供接口具体实现，服务调用方调用接口；

API：服务提供方提供接口和实现，提供调用方调用接口；



## 7.SPI的优缺点

通过Service Provider Interface（SPI）机制，确实可以大大提高接口设计的灵活性，因为它允许服务提供者定义接口，**而多个实现者可以独立地实现这些接口**，且在运行时可以动态加载具体的实现。然而，SPI机制也存在一些缺点，主要包括以下几点：

1. 遍历加载所有实现类
   - **效率问题**：SPI机制通常会遍历所有可用的服务提供者实现类。这个过程在实现类数量较多时会导致性能问题，因为每次调用`ServiceLoader`都会加载并实例化所有的实现类 ([U.OSU](https://u.osu.edu/mclc/2019/06/11/a-history-of-gaokao-essay-questions/))。
2. 并发问题
   - **线程安全**：当多个`ServiceLoader`实例同时加载服务实现时，可能会出现并发问题。这是因为`ServiceLoader`类本身并不是线程安全的，多线程环境下需要额外的同步措施来避免并发冲突 ([U.OSU](https://u.osu.edu/mclc/2019/06/11/a-history-of-gaokao-essay-questions/)) 。



优点：大大提高了接口设计的灵活性；

缺点：需要遍历加载所有的实现类，效率较低；当多个ServiceLoader同时load时，会有并发问题。



## 8.什么是序列化和反序列化？

持久化Java对象，需要用到序列化；



序列化：将数据结构或对象转换成二进制字节流的过程；

反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程；



应用：RPC远程调用、对象存储到Redis缓存



## 9.JDK自带的序列化实现

对象实现Serializable接口，

```java
private static final long serialVersionUID = 1905122041950251207L;
```

版本控制的作用，反序列化的时候会检查时否和当前类的UID一致，如果不一致会抛出InvalidClassException异常；



为什么是static？

`static` 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，`serialVersionUID` 是一个特例，`serialVersionUID` 的序列化做了特殊处理。当一个对象被序列化时，`serialVersionUID` 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。如果两者不匹配，反序列化过程将抛出 `InvalidClassException`，因为这通常意味着序列化的类的定义已经发生了更改，可能不再兼容。

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/java/basis/serialization.html



如果有些字段不想序列化？

使用transient关键字



为什么不推荐JDK自带的序列化？

- 不支持跨语言；
- 性能差
- 存在安全问题





有什么推荐的序列化工具？

Kryo，高性能

Protobuf，出自google



## 10.Java IO流了解吗？

IO：输入和输出，输入是将数据输入到内存，输出是将数据从内存输出到文件等；Java IO流可以分为，输入流和输出流，数据的处理方式分为字节流和字符流。



Java中IO流的四个基类：InputStream Reader OutputStream Writer



## 11.IO流为什么要分为字节流和字符流？

为了**更好处理**不同类型的数据；

字节流：处理二进制数据，图形、音乐、视频



字符流：处理文本数据；如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。



## 12. 什么是语法糖？

为了方便程序员使用的一种特殊语法，底层的实现都是普通的语法构成，例如增强for循环，底层就是简单的for循环和迭代器；

自动装箱和自动拆箱，Integer.valueOf(int i )  i.intValue()



## 13.有哪些常见的语法糖

泛型、for each、自动拆装箱、变长参数（底层使用的String数组）、try-with-resources（使用try catch finally）



# Java集合

## 1.说说对Java集合的了解？

Java集合框架，也叫做容器，主要有两大接口派生，Collection接口，单列集合，主要子接口有List（ArrayList、LinkedList）、Set（HashSet、TreeSet、LinkedHashSet）、Queue（PriorityQueue、ArrayDeque）；Map接口，双列集合，实现类有HashMap、HashTable、LinkedHashMap、TreeMap；

<img src="./assets/image-20240515114715550.png" alt="image-20240515114715550" style="zoom:50%;" />



## 2.说说List、Set、Queue、Map的区别？

List：有序、有索引、可重复

Set：不可重复

Queue：有序、可重复，按特定的排队规则来确定先后顺序；

Map：key-value双列集合，key无序、不可重复；



## 3.为什么要使用集合？

相比于数组，，**长度可变**，**支持泛型**，**多样化的操作方法**。



## 4.ArrayList和数组的区别？

1. 长度可变
2. 可以使用泛型
3. 只能使用对象，基本类型的包装类
4. 丰富的API操作方法
5. 创建时，不需要指定大小；



## 5.为什么LinkedList不能实现RandomAccess接口？

RandomAccess接口是一种标记，可以随机快速访问的标记，LinkedList内存地址不连续，不能随机快速访问。



## 6.ArrayList和LinkedList的区别？

1. 底层结构：动态对象数组、双向链表
2. 是否支持快速随机访问
3. 空间占用：预留空间、存放前后继内存地址
4. 插入删除是否受元素位置影响：LinkedList在头尾的插入删除不受位置影响；



## 7.说说ArrayList的扩容机制

使用无参构造函数，添加第一个元素时，才会初始化容量为10

add方法：

1. 首先将当前元素个数+1与容量做比较；
   1. 调用ensureCapacityInternal（size+1）方法，
      1. 内部调用ensureExplicitCapacity（calculateCapacity(数组，minCapacity)）方法；
      2. calculateCapacity方法内部判断原数组是否为空，为空则返回size+1和10的最大值，否则返回size+1；
      3. ensureExplicit(minCapacity)方法判断min和数组容器比较，决定是否需要调用grow（min）方法；



grow方法：

1. 将老容量扩容1.5倍，作为新容量的值；
2. 判断新容量与minCapacity的大小，如果新容量小，则赋值为minCapacity；
3. 将新容量与int的最大值比较，看是否超出最大值；
4. 调用Arrays.copyOf(老数组，新容量)方法，底层是创建新数组，将老数组的元素移到新数组；



答：

1. 扩容机制主要探究add和grow方法；
2. add方法添加元素，会首先判断当前数组size+1是否超出数组容量，如果超出数组容量则进入grow方法；
3. 进入grow方法，对容量进行1.5倍扩容，将新容量与最小需要容量比较大小，如果新容量小则会赋值为最小需要容量；
4. 进入Arrays.copyOf(数组，新容量)获取扩容后的数组；
5. 根据数组索引进行添加新元素；



## 8.Comparable和Comparator的区别？

`Comparable` 接口实际上是出自`java.lang`包 它有一个 `compareTo(Object obj)`方法用来排序

`Comparator`接口实际上是出自 `java.util` 包它有一个`compare(Object obj1, Object obj2)`方法用来排序

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/java/collection/java-collection-questions-01.html



## 9.Set集合的无序性和不可重复性的含义是什么？

无序性：不是按照数组的索引，而是按照哈希值决定位置；



不可重复性：重写equals和hashCode方法，equals方法返回false；



## 10.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

同：

1. 都是Set的实现类；
2. 都能保证元素的唯一性；
3. 都有线程安全问题；



异：

1. 底层数据结构：哈希表（基于HashMap）、哈希表+链表、红黑树
2. 应用场景：不需要保证插入和取出顺序、插入和取出顺序相同、自定义排序规则；



## 11.Queue和Deque的区别

1. Queue是单端队列，扩展了Collection接口，offer、poll、peek
2. Deque是双端队列，扩展了Queue，offerFirst、offerLast等
3. Deque还能模拟栈，提供了push、pop方法



## 12.ArrayDeque和LinkedList的区别？ 

两者都实现了Deque接口，都具有队列的功能；



1. 底层数据结构：数组+双指针、双向链表；
2. ArrayDeque不支持存储null数据；
3. ArrayDeque实现队列更好；



## 13.说说PriorityQueue？

定义队列中元素出队顺序的优先级



`PriorityQueue` 利用了二叉堆的数据结构来实现的，**底层使用可变长的数组来存储数据**

`PriorityQueue` 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。

`PriorityQueue` 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。

`PriorityQueue` 默认是**小顶堆**，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/java/collection/java-collection-questions-01.html



## 14.HashMap和HashTable的区别？

1. HashTable线程安全；
2. 底层数据结构：HashMap有将链表转化为红黑树的机制；
3. HashMap支持key为null，但只能有一个；
4. HashMap初始值为16，扩容为2倍；HashTable初始为11，扩容为2n+1；如果是指定的初始值，HashMap会扩充为2的幂次方大小；



## 15.HashMap和HashSet的区别？

1. 实现了Map接口、实现了Set接口；
2. 存储键值对、存储对象；
3. HashSet底层是基于HashMap实现；
4. 使用key来计算hashCode、使用成员对象来计算hashCode值；

| HashMap         | HashSet                                                |
| --------------- | ------------------------------------------------------ |
| Map接口         | Set接口                                                |
| 键值对          | 对象                                                   |
| put方法添加元素 | add方法添加元素                                        |
| key计算hashCode | 成员对象计算hashCode，需要同时重写equals和hashCode方法 |



## 16.HashMap和TreeMap的区别？

TreeMap对元素根据键排序；



HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。

HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。

HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/qq_44491991/article/details/115472686





## 17.HashSet如何检查重复？

首先检查hashCode值来判断是否有哈希冲突，如果没有，则说明元素不重复，如果存在哈希冲突，然后调用equals方法来判断对象是否相等，如果不相等，则说明元素不重复；



## 18.HashMap的底层实现？*

解决哈希冲突，当链表长度大于8时，且数组长度大于64，进行树化，链表转化为红黑树；



HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。



### put方法详解

put方法调用putVal方法，流程如下：

1. table是否初始化或者长度为0，进行扩容；
2. hash&(n-1)计算桶的索引，桶为空，存放新节点；
3. （处理哈希碰撞），判断第一个的key是否与新节点相同，相同则直接替换；
4. 判断链表是否是红黑树，是树，则让放入树中；
5. 遍历链表，如果有节点的key相同则替换value。否则在尾部插入；
6. 插入之后，判断节点数量是否大于8，大于8则进入树化方法；
7. 最后判断实际大于是否大于阈值，进行扩容；



### get方法详解

get方法调用getNode方法，流程如下：

1. 首先判断桶不为空，且长度不为0，且key的哈希值&(n-1)的索引位置不为空；
2. 通过哈希值和equeals比较相等找出是否存在key；



### resize方法详解

扩容方法的流程如下：

1. 如果table已经初始化，扩容为2倍；
2. 如果table指定了初始化容量，将初始化容量赋给容量；
3. 如果table没有初始化，初始化容量为16，阈值为12；
4. 如果是指定了初始化容量，进行阈值初始化；
5. 创建一个新的哈希表；
6. 如果旧哈希表不为空，则将旧哈希表的元素都移到新哈希表中；











## 19.HashMap的长度为什么是2的幂次方？

因为hashMap底层计算后的哈希值，需要进行对长度取余来计算索引值，而为了提高运算效率，将hash%length转换为hash&(length-1)，前提是length是2的n次方。&是二进制操作符；



## 20.HashMap多线程操作导致死循环问题？

JDK1.7 及之前版本的 `HashMap` 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。

为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 `HashMap`，因为多线程下使用 `HashMap` 还是会存在数据覆盖的问题。并发环境下，推荐使用 `ConcurrentHashMap` 。

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/java/collection/java-collection-questions-02.html



## 21.HashMap为什么线程不安全？

putVal方法中，

产生哈希冲突时，可能会发生数据覆盖；

添加元素完成之后，size++操作时，线程 1、2 都执行了一次 `put` 操作，但是 `size` 的值只增加了 1，也就导致实际上只有一个元素被添加到了 `HashMap` 中。



## 22.HashMap的常见遍历方式？

1. Map.Entry<Integer,String> entry = map.entrySet()，获取所有的entrySet，entry.getKey()，entry.getValue()
2. map.keySet()，获取所有的key



## 23.ConcurentHashMap和HashTable的区别？

底层数据结构：数组+链表+红黑树、数组+链表

保证线程安全的方法：

1. CAS和Synchronized锁，对判断哈希冲突和链表增加节点；
2. Synchronized，直接锁住整个数组；



## 24.为什么ConcurrentHashMap不能有null的key和value？

### 具体例子

假设我们有一个并发环境中使用的 `ConcurrentHashMap`，其中 `null` 键和值是允许的。以下是一个可能出现的问题场景：

1. **线程 A 检查键是否存在**：
   - 线程 A 执行 `map.containsKey(key)`，检查某个键是否存在。
2. **线程 B 同时修改键的值**：
   - 在同一时间，线程 B 执行 `map.put(key, null)`，将某个键的值修改为 `null`。

### 可能出现的问题

- **歧义和不确定性**：
  - 当线程 A 执行 `map.containsKey(key)` 时，如果它发现键存在但值为 `null`，它可能会误认为键不存在（因为在一些上下文中，`null` 可能被用作表示不存在的键）。
  - 这会导致线程 A 做出错误的决策。例如，它可能尝试插入这个键（认为键不存在），而实际上键已经存在，但值为 `null`。
- **并发操作的竞态条件**：
  - 如果线程 A 和线程 B 在接近的时间点进行操作，可能会产生竞态条件。例如，线程 A 检查到键存在，然后线程 B 将值修改为 `null`，然后线程 A 继续其逻辑（如读取值），此时得到的是 `null`。这会导致逻辑错误，因为线程 A 原本预期的是一个非 `null` 的值。





# Java并发常见面试题

## 1.什么是线程和进程？

何为进程？



进程是程序的一次运行过程，是程序的实例；

程序由指令和数据组成，指令需要加载到CPU运行，数据需要加载到内存，指令的运行还需要磁盘、网络等设备的支持。进程的作用就是加载指令、管理内存、管理网络等设备；

程序的运行其实就是，从磁盘中将代码读取到内存中；



何为线程？



线程是进程的子集，线程是最小调度单位，一个进程可以有多个线程；

一个线程就是一条指令流，线程将指令按照一定顺序交给CPU运行；





## 2.请简要描述进程与线程的关系，区别和优缺点？

关系：线程是进程的子集。

区别：进程之间是独立的，线程则不一定；

优缺点：线程开销小，不利于资源的管理和保护；进行相反；



## 3.如何创建线程？

1. 继承Thread类；
2. 实现Runable接口
3. 实现Callable接口，重写Call方法，线程执行结果返回；
4. 使用线程池；



## 4.说说线程的生命周期和状态？

在Java中线程的生命周期可以分为六个：

1. NEW：初始状态，没有start的线程；
2. RUNNABLE：运行状态，
3. BLOCKED：阻塞状态，**等待锁的过程**
4. TIME_WAITNG：有时间的等待状态，**等待被唤醒；**
5. WAITNG：等待状态，**等待被唤醒**；
6. TERMINATED：终止状态，表示线程运行完毕；



## 5.什么是线程上下文切换

线程上下文：上下文是指线程的运行条件和状态，程序计数器、虚拟机栈、本地方法栈就是线程的上下文；



线程上下文切换，线程A让出CPU，线程B占用CPU；



什么情况下会发生？

1. 线程A的时间片用完了；
2. 线程A执行完毕；
3. 线程A调用了sleep，wait，join等方法；



## 6.Thread.sleep和Object.wait方法对比

1. sleep方法没有释放锁，wait会释放锁；
2. wait苏醒需要其他线程调用同一个对象上的notify或notifyall方法；
3. wait用于线程间交互，sleep用于暂停执行；
4. sleep是Thread的静态本地方法，wait是Object的本地方法；





## 7.为什么wait方法不定义在Thread中？

wait方法是让获得对象锁的线程实现等待，将占有本对象的对象锁的线程释放对象锁，进入等待唤醒状态；



## 8.可以直接调用Thread类的Run方法吗？

直接调用run方法，而不是通过start线程去自动执行run方法的话，那么run方法就不会以多线程的方式执行；



## 9.并发与并行的区别？

并发：同一时间dealing with多件事情；

并行：同一时间doing多件事情；



## 10.同步与异步的区别？

同步：需要等待结果返回；

异步：不需要等待结果返回；



## 11.为什么要使用多线程？

1. 提高CPU利用率：单个线程的话，线程阻塞，CPU就空闲了；
2. 提供程序的执行效率；
3. 实现高并发；



## 12.使用多线程可能带来什么问题？

1. 死锁；
2. 线程不安全：多线程同时修改同一个变量，导致数据不一致；



## 13.如何理解线程安全和不安全？

线程安全：多线程下，对于同一份数据都能保证这份数据的正确性和一致性；



线程不安全：多线程下，不能保证同一个数据的正确性和一致性；



## 14.单核CPU上运行多线程效率一定会高吗？

不一定；

线程有CPU密集型和IO密集型，在单核CPU下每次都只能有一个线程运行，如果是CPU密集型，则会有大量的线程上下文切换，效率会降低；如果是IO密集型，多线程可以提高效率；



## 15.什么是线程死锁？

线程A占有资源1，线程B占有资源2，线程A试图获取资源2，线程B试图获取资源1，两个线程相互等待进入了死锁。



产生死锁的四条必要条件：

1. 互斥条件：资源只能被一个线程占用；
2. 请求与保持条件：一个线程因为请求资源阻塞时，会保持已有的资源；
3. 不剥夺条件：线程不能强行剥夺其他线程占有的资源；
4. 循环等待条件：多个线程之间形成循环等待资源关系；



## 16.如何检测死锁？

使用JConsole工具排查；



## 17.如何预防和避免线程死锁？

预防死锁，破坏死锁的必要条件：

1. 破坏请求与保持条件：一次性申请所有的资源；
2. 破坏不剥夺条件：线程申请其他资源的时候，先释放自己的资源；
3. 破坏循环等待条件：按照顺序来申请和释放资源；



避免死锁：锁的顺序，确保所有线程在获取多个锁时按照相同的顺序进行；





## -----------------------------------

## 1.如何保证变量的可见性？

对变量使用volatile关键字，指示编译器，这个变量是共享且不稳定的，每次使用它都需要到主存中进行读取；



## 2.如何禁止指令重排序？



```java
public class Singleton{
    private static volatile Singleton uniqueInstance;
    
    public Singleton(){
        
    }
    
    public Singleton getInstance(){
        if(uniqueInstance == null){
            synchronized(Singleton.class){
                if(uniqueInstance == null) uniqueInstance = new Singleton()
            }
        }
        return uniqueInstance;
    }
}
```



双重检测锁方式实现单例模式，流程如下：

1. 为uniqueInstance分配内存空间
2. 初始化uniqueInstance
3. 将uniqueInstance引用指向内存空间；



指令重排序，JVM虚拟机可能会将指令按照1-3-2来执行，打乱指令顺序，而加上了volatile关键字，则不会进行指令重排序；

单线程下不会出问题，多线程下，线程A执行了1-3，线程B发现uniqueInstance不为空，返回uniqeuInstance对象，然而uniqueInstance还没有初始化。



底层插入了特定的内存屏障；



还可以通过Unsafe类的三个内存屏障方法来防止重排序（loadFence、storeFence、fullFence）；



## 3.volatile可以保证原子性吗？

可以保证变量的可见性，但是无法保证对变量操作的原子性，

即，多线程对变量操作的时候，依然存在线程安全问题；



## 4.什么是悲观锁？

synchronized、ReentrantLock锁都是悲观锁思想的实现；



悲观锁：认为共享资源每次被访问的时候都会出现问题，所以每次获取资源的操作都需要上 锁；只有一个线程能获取资源，其他线程阻塞；



造成大量线程阻塞，死锁问题，线程上下文切换耗费资源；



## 5.什么是乐观锁？

CAS是乐观锁思想的实现；



乐观锁：认为共享资源每次被访问的时候都不会出现问题，每次获取资源的操作都只是比较资源是否改变。





频繁的失败和重试，影响性能；



## 6.如何实现乐观锁？

使用版本号和CAS算法；



版本号：给数据加一个版本号，数据被更新，需要将版本号+1；每次修改数据前，都需要先获取版本号，如果版本号与当前数据的版本号相等则更新数据，否则重试更新操作，直到更新成功。



CAS算法：比较并且交换，先比较值是否和预期的值相等，相等的话则更新；三个参数，需要比较的值的内存地址，预期的值，更新的值；



## 7.CAS算法存在哪些问题？

ABA问题：当比较的预期值相等时，不一定能确定变量没有被修改过，假如数据被修改成B然后又修改回来了呢？

解决方法：在变量前加上版本号或时间戳；



循环时间长开销大：CAS如果比较不成功则会一直重试直到成功，CPU开销大；

解决方法：JVM支持pause指令，pause指令能够让自旋的时候暂停一小会；



只能保证一个共享变量的原子操作；

解决方法：jdk1.5开始，可以把多个共享变量放到一个对象里来进行CAS操作；



## 8.synchronized是什么？有什么用？

Java中的关键字，翻译成中文是同步的意思；

主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或代码块在任意时刻只能有一个线程执行；



## 9.如何使用Synchronized？

1. 修饰实例方法：锁是当前对象实例；
2. 修饰静态方法：锁是当前类；
3. 修饰代码块：synchronized(实例对象/类.class)



## 10.构造方法可以用synchronized修饰吗？

构造方法不能；但是构造方法内部的代码块可以使用synchronized修饰；



构造方法是线程安全的，但是如果构造方法内部涉及到的共享资源的操作，就需要采用适当的同步措施来保证线程安全；



## 11.synchronized的底层原理？

JVM会为每个对象锁关联一个Monitor监控，包含三个属性，Owner指向占有对象锁的线程，EntryList是等待锁的阻塞线程，WaitSet是获取锁的线程调用了wait方法进入等待；

obj对象头的Mark Word存放Monitor的地址，获取锁的过程：

1. 线程A获取obj对象锁，monitor的owner指向线程A；
2. 线程B申请获取obj对象锁，检查monitor发现onwer不为空，则进入EntryList阻塞队列；
3. 线程A释放对象锁之后，monitor的onwer为空，然后唤醒EntryList的阻塞线程；



## 12.synchronized做了哪些优化？锁升级原理了解吗？



见JUC并发编程；



## 13.synchronized和volatile的区别？

1. volatile关键字只能用于变量，而synchronized关键字可以修饰方法和代码块；
2. volatile关键字能保证数据的可见性，但不能保证数据的原子性；synchronized都能保证；
3. volatile用于解决变量在多个线程之间的可见性，而synchronized解决多个线程之间访问资源的同步性；



## 14.ReetrantLock是什么？

ReetrantLock实现了Lock接口，是一个可重入且独占式的锁，和synchronized关键字类似，更灵活和强大，增加了轮询、超时、中断、公平锁和非公平锁功能；



## 15.synchronized和ReentrantLock的区别？

1. 是否可中断
2. 是否支持公平锁
3. 选择性唤醒wait中的线程
4. synchronized依赖于jvm，而reentrantLock依赖于API



## 16.共享锁和独占锁的区别

共享锁：一把锁可以同时被多个线程获得



## 17.线程持有读锁还能获取写锁吗?

不能；

线程持有写锁的话，当前线程可以同时去获取读锁，如果是其他线程的话，则不能获取。



## 18.读锁为什么不能升级为写锁？

写锁是独占式锁，读锁是共享锁；

写锁可以降级为读锁，因为一个线程获取写锁的时候，没有其他线程能够持有读锁或写锁；



读锁如果升级为写锁的话，线程A和B都持有读锁，如果允许升级为写锁的话，线程AB都需要等待对方释放读锁（为了满足写锁独占式的特性），会产生死锁，也会消耗性能；





## 19.ThreadLocal有什么用？

为每个线程绑定自己的值，每个线程都可以拥有属于自己的本地变量；

```java
public static ThreadLocal<Integer> threadLocals = new ThreadLocal<>();

public void set(int i){
    threadLocals.set(i);
}
```



set的底层是：

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        map.set(this, value);
    } else {
        createMap(t, value);
    }
}
```



getMap的底层是：

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```



threadLocals是Thread类中的一个属性，是线程私有的，

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
```





ThreadLocal是线程共享的，ThreadLocalMap是线程私有的，

ThreadLocalMap中的key是ThreadLocal，value是用户需要存储线程私有的值；



## 20.ThreadLocal内存泄漏是怎么导致的？

问题来源：

ThreadLocal变量作为key是弱引用，在GC期间会被清除，然而value是强引用，不会被GC，导致ThreadLocalMap中存在key为null的value条目。

如果我们不做处理的话，那么value就永远无法清除。



解决方法是：

1. 每次使用完ThreadLocal后，手动调用remove方法；
2. ThreadLocalMap类里面的set get remove方法会自动清理key为null的记录；



### 自我保护机制的具体操作

1. **`get` 方法**：在获取值的时候，如果发现 `Entry` 的 `key`（即 `ThreadLocal` 实例）已经被回收，则会清理这个 `Entry`。
2. **`set` 方法**：在设置值的时候，如果发现某个 `Entry` 的 `key` 已经被回收，则会清理这个 `Entry` 并插入新的 `Entry`。
3. **`remove` 方法**：显式地移除 `ThreadLocal` 对应的值，并清理相关的 `Entry`。

### 为什么仍然无法完全避免内存泄漏？

尽管有上述自我保护机制，内存泄漏问题仍然可能发生，原因如下：

1. **弱引用的清理时机**：即使 `ThreadLocal` 实例被垃圾回收了，但它对应的 `Entry` 只是 `key` 被设为 `null`，`value` 仍然存在于 `ThreadLocalMap` 中，只有当 `ThreadLocalMap` 进行下一次操作（`get`、`set` 或 `remove`）时，才会进行清理。如果没有新的操作，这些 `value` 可能会一直存在，导致内存泄漏。
2. **线程的生命周期**：`ThreadLocalMap` 是存储在线程中的。如果线程是线程池中的线程，它可能会长时间存在甚至永不终止。在这种情况下，如果 `ThreadLocal` 没有显式调用 `remove` 方法，那么对应的 `Entry` 的 `value` 可能会一直存在，导致内存泄漏。
3. **业务逻辑复杂性**：在复杂的业务逻辑中，开发者可能会遗漏调用 `remove` 方法。即使 `ThreadLocalMap` 有自我保护机制，如果没有触发相应的操作，这些无用的 `value` 也不会被清理。



## ----------------------------------------------

## 1.什么是线程池？

线程池就是管理一系列线程的资源池，当有任务要处理的时候，直接从线程池中取出线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。



## 2.为什么要用线程池？

1. 降低资源消耗：通过利用已经创建的线程来降低线程创建和销毁的消耗；
2. 提高响应速度：无需等待线程创建；
3. 提高线程的可管理性：使用线程池对线程进行统一分配、调优和监控；



## 3.如何创建线程池？

1. 通过ThreadPoolExecutor构造函数来创建；
2. 通过Executor框架的工具类Executors来创建；

```java
  public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
```

[java线程池使用详解ThreadPoolExecutor使用示例_threadpoolexecutor使用案例-CSDN博客](https://blog.csdn.net/xu_yong_lin/article/details/117521773)





1. FixedThreadPool：固定线程数量；
2. SingleThreadPool：只有一个线程；
3. CacheThreadPool：根据实际情况调整线程数量；
4. ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务；





## 4.线程池的拒绝策略有哪些？

如果当前线程池的线程数量已经达到最大线程数量，并且队列中也已经满了，那么当有新任务来时，ThreadPoolExecutor定义了一些拒绝策略：

1. AbortPolicy：抛出RejectedExecutionException异常来拒绝任务；
2. CallerRunsPolicy：使用调用方的线程来运行任务。如果调用方的程序关闭了，则会丢弃该任务；
3. DiscardPolicy：不处理，直接丢弃；
4. DiscardOldestPolicy：丢弃最早的未处理的任务；



## 5.如果不允许丢弃任务，应该选择哪个拒绝策略？

CallerRunsPolicy：，只要当前程序不关闭，就会使用执行execute方法的线程执行该任务；



## 6.CallerRunsPolicy有什么风险，如何解决？

如果走到CallerRunsPolicy的任务非常耗时，并且提交任务的线程是主线程，那么会导致主线程阻塞，影响程序正常执行，甚至可能引发OOM；



如何解决？

1. 增加阻塞队列的容量；
2. 增加线程池的最大线程数；
3. 持久化任务
   1. 存储到MYSQL;
   2. 存储到Redis；
   3. 提交到消息队列；



持久化任务的具体实现：

1. 重写RejectedExecutionHandler接口自定义拒绝策略，将线程池无法容纳的任务持久化到MYSQL；
2. 继承BlockingQueue实现一个混合式阻塞队列，该队列包含JDK自带的ArrayBlockingQueue，重写take方法，取任务时优先从数据库中取出；



## 7.线程池常用的阻塞队列有哪些？

结合内置线程池来分析，Executors工具类中的线程池：

1. 容量为Interger.MAX_VALUE的LinkedBlockingQueue阻塞队列：FixedThreadPool和SingleThreadPool，前者核心线程和最大线程相等，后者只有一个线程；
2. SynchronousQueue阻塞队列：CacheThreadPool，该阻塞队列没有容量，不存储元素，只是当有新任务时，无论如何都会分配线程来执行任务（空闲线程或者新建线程），线程数量是无限的。
3. DelayedWorkQueue：ScheduledThreadPool和SingleThreadScheduledExecutor，按照延迟的时间长短对任务进行排序，队列满了之后会自动扩容为1.5倍，最大容量为MAX_VALUE。



## 8.线程池处理任务的流程了解吗？

1. 如果当前运行的核心线程池未满，则创建新线程；
2. 如果当前运行的核心线程池已满，则检查等待队列是否已满；
3. 如果等待队列未满，则加入队列；
4. 如果等待队列已满，则检查最大线程池是否已满；
5. 如果最大线程池未满，则创建新线程；
6. 如果最大线程池已满，则根据拒绝策略处理；



## 9.线程池中线程异常后，销毁还是复用？

使用execute提交任务时，线程异常，会销毁线程，并且创建新线程替换；

使用submit提交任务时，线程异常，会将异常封装到Future中，线程复用；



## 10、如何设计一个能够根据任务的优先级来执行的线程池？

使用PriorityBlockingQueue优先级阻塞队列，

1. 实现Comparable接口，重写CompareTo方法；
2. 传入Comparator对象指定任务之间的排序规则；



存在的问题：

1. 该阻塞队列是无界的，可能会导致OOM；
2. 饥饿问题，优先级低的任务长时间得不到执行；
3. 由于需要对队列中的元素进行排序和保证线程安全，会降低性能；



如何解决？

1. 集成PriorityBlockingQueue并重写offer方法，当插入的元素数量超过指定值就返回false；
2. 优化设计，当任务长时间得不到执行时，移除并重新添加到队列中，并提高优先级；
3. 无法避免；



## 11.Future类有什么用？

将任务交给Future来异步执行，期间可以取消任务、获取任务执行状态、获取任务结果；



## 12.Callable和Future的关系？

callable作为任务，放入FutureTask（实现了Futrue接口和Runable接口），作为任务；



## 13.CompletableFuture类有什么用？

是对Future的加强，解决了Future不支持异步任务的编排组合、获取计算结果的get方法为阻塞调用；

异步任务编排组合（将多个异步任务串联起来，组成一个完整的链式调用）等能力。



## 14.AQS是什么？

AQS的全称是AbstractQueuedSynchronizer，抽象队列同步器，用来构建锁和同步器；



ReentrantLock、Semaphore（信号量）



## 15.AQS的原理是什么？

AQS的核心思想是，共享资源如果是空闲的，则请求的线程设为工作线程，资源上锁；共享资源已经有锁了，则将请求的线程进入CLH队列；



CLH队列是虚拟队列，是由每个节点组成的，节点由线程引用、在队列中的状态、前驱节点、后驱节点组成

![image-20240523085745381](./assets/image-20240523085745381.png)



AQS使用int类型的state表示同步状态，通过内置的线程等待队列来完成线程的阻塞；



state为0表示未锁定状态，state为1表示锁定状态，state可以累加，表示锁的重入次数；



## 16.Semaphore有什么用？

```java
final Semaphore semaphore = new semaphore(5);
try {
    semaphore.acquire(); // 获取信号量，如果没有可用的许可证，线程将被阻塞
    // 访问共享资源的代码
} catch (InterruptedException e) {
    // 处理中断异常
} finally {
    semaphore.release(); // 释放信号量，增加一个许可证
}
```



Semaphore可以设置同时访问共享资源的线程数量，当设置的值为1时，Semaphore退化为排他锁；



Semaphore的构造方法可以传入一个fair(boolean)类型，指定是否为公平模式（先到先得）;

## 17.Semaphore的原理是什么？

默认构造permits为AQS的state，许可证的数量；

semaphore调用acquire方法，线程尝试获取许可证，如果state大于等于0的话，获取成功；获取成功，使用CAS去修改state的值减一；否则，创建一个阻塞队列；



调用release，线程尝试释放许可证，并使用CAS操作去修改state的值加一；释放成功，唤醒同步队列中的线程；被唤醒的线程重新尝试去修改state-1，如果state>=0，则获取成功，否则重新进入阻塞队列；



## 18.CountDownLatch有什么用？

运行count个线程阻塞在一个地方，直到所有线程的任务都执行完毕；



是一次性的，计数器的值只能在构造方法中初始化一次；



## 19.CountDownLatch的原理是什么？

共享锁的一种实现，将count设置为AQS的state，使用countDown以CAS的操作来减少state，直到state为0；当调用await方法，检测state是否为0，不为0则阻塞，直到任务全部执行完毕；



## 20.用过CountDownLatch吗？什么场景下使用的？

CountDownLatch是设置数量count，运行有count个线程来执行任务，直到所有线程都执行完毕；



做过一个项目，读取六个文件，这六个任务没有相互依赖，但是我们需要返回给用户的时候将文件处理结果进行统计整理；

```java
public class CountDownLatchExample1 {
    // 处理文件的数量
    private static final int threadCount = 6;

    public static void main(String[] args) throws InterruptedException {
        // 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; i++) {
            final int threadnum = i;
            threadPool.execute(() -> {
                try {
                    //处理文件的业务操作
                    //......
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    //表示一个文件已经被完成
                    countDownLatch.countDown();
                }

            });
        }
        countDownLatch.await();
        threadPool.shutdown();
        System.out.println("finish");
    }
}

```





## --------------------------------------

# JVM

## 1.介绍下Java内存区域（运行时数据区）

线程私有：

1. 程序计数器：唯一不会发生OOM的区域。
2. 虚拟机栈：栈帧（局部变量表、操作数栈、动态链接、方法返回地址）
3. 本地方法栈



线程共享：

1. 堆：几乎所有的对象和数组都是在此分配内存（如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存）；
2. 方法区：存储已被虚拟机加载的 类的元信息、JIT编译后的代码、运行时常量池
3. 直接内存



运行时常量池：编译器生成的各种字面量（例如“5”）、符号引用（“java/lang/String”），类似于传统编程语言的符号表



**为什么年龄只能是 0-15? **

因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。





为什么取消永久代，而使用元空间？

1. 永久代存在堆中，受JVM内存的限制，元空间在本地内存，受本机可用内存的限制，内存溢出几率更小。
2. 元空间存放的是类的元数据，这样加载多少类的元数据由本地内存的空间来控制，可以加载更多的类。
3. 永久代增加了GC的复杂度。
4. JDK8时，HotSpot和JRockit合并，JRockit没有永久代的概念。



为什么字符串常量池要从从永久代移动到堆中？

因为字符串常量池里面的内容需要不断进行回收，但是永久代的回收效率太低了。



![image-20240523103822546](./assets/image-20240523103822546.png)



![image-20240523103831331](./assets/image-20240523103831331.png)



![image-20240523103842949](./assets/image-20240523103842949.png)





![image-20240523103854306](./assets/image-20240523103854306.png)



![image-20240523103904692](./assets/image-20240523103904692.png)



![image-20240523103927356](./assets/image-20240523103927356.png)



## 2.Java对象的创建过程？

五步，必须能默写出来，并且知道每一步虚拟机做了什么



1. 类加载检查：JVM遇到一条new指令时，首先会去检查运行时常量池中是否存在该类的符号引用，并且检查该类是否已被加载，如果没有，则进行类加载。

2. 分配内存：类加载检查完毕后，JVM为对象分配内存，分配方式有两种，指针碰撞（类似于复制算法）和空闲列表（类似于标记清除）；

3. 初始化零值：分配内存完毕之后，JVM将分配到的内存空间都初始化为零值，保证对象的实例字段不赋初值就直接使用；

4. 设置对象头：初始化零值后，JVM设置对象头，对象所属类、对象的哈希码、分代年龄等信息；

5. 执行init方法：JVM把对象按照程序员的意愿进行初始化。

   

   





## 3.对象的访问定位的两种方式？

句柄和直接指针两种方式；

![image-20240524111310821](./assets/image-20240524111310821.png)



![image-20240524111321005](./assets/image-20240524111321005.png)

句柄访问：对象移动时，不需要改变局部变量表的reference引用；

直接访问：速度快，节省了一次指针定位的时间开销；



两者的区别是：局部变量表中的Reference指向的是否是对象的实例数据；



## 4.如何判断对象是否死亡？

引用计数法：给对象添加一个引用计数器，只要有一个地方使用了对象，计数器+1，否则-1，当引用计数器为0，说明对象已经死亡；缺点在于，无法解决两个对象相互依赖的时候，但是其他地方没有使用它们，那么这两个对象实际上已经死亡，然而计数器都为1；



可达性分析算法：通过定义一些列GC Roots对象，作为引用链的起点，没有处在GC Roots引用链上的对象需要回收。



哪些对象可以作为GC Root：

1. 虚拟机栈（局部变量表）中的引用的对象；
2. 本地方法栈（Native方法）中引用的对象；
3. 方法区中类静态属性引用的对象；
4. 方法区中常量引用的对象；
5. 所有被同步锁持有的对象；
6. JNI（Java Native Interface）引用的对象；





## 5.简单介绍一下强引用、软引用、弱引用、虚引用

- **强引用**：对象不会被回收，除非没有强引用指向它。
- **软引用**：内存不足时会回收，用于实现内存敏感的缓存。
- **弱引用**：垃圾回收时总会回收，用于规范映射（多个引用指向同一个实例）。
- **虚引用**：无法直接访问对象，用于跟踪对象回收状态。

## 6.如何判断一个常量是废弃常量



假如字符串常量池中存在字符串"abc"，如果没有任何字符串对象引用该字符串常量的话，那么"abc"就是废弃常量；





## 7.如何判断一个类是无用的类



1. 堆中不存在该类的实例；
2. 加载该类的ClassLoader已经回收；
3. 该类的Class对象没有在任何地方被引用（防止反射）







## 8.垃圾收集有哪些算法，各自的特点？







## 9.HotSpot为什么要分为新生代和老年代？

因为对象的存活周期不同，需要垃圾收集的机制也不同，分为新生代和老年代，可以更好管理堆内存的垃圾收集；新生代的对象存活周期都较短，每次垃圾收集都会有大量对象死亡，选择复制算法，而老年代的对象存活周期长，垃圾收集频率低，选择标记-清除或者标记-整理算法；



## 10.常见的垃圾回收器有哪些？





## 11.介绍一下CMS G1收集器？



## 12.Minor GC和Full GC的区别？



Minor GC 对新生代进行垃圾收集，Full GC对整个堆和方法区进行垃圾收集；



触发条件：Eden区满；老年代空间不足，方法区空间不足，调用System.gc()；



造成影响：程序短暂暂停；程序长时间暂停；



## -----------------------------------



# MyBatis常见面试题

## 1.#{}和${}的区别是什么？

${}是变量占位符，会拼接到SQL语句中，原样替换；



#{}是参数占位符，对预编译的语句使用PreparedStatement进行参数设置，防止SQL注入；

```java
PreparedStatement ps = connection.prepareStatement("SELECT * FROM users WHERE username = ?");
ps.setString(1, username);


```



## 2.xml映射文件中，除了场景的增删改查标签外，还有哪些标签？



resultMap

```xml
<mapper namespace="com.example.UserMapper">

    <!-- SQL查询语句 -->
    <select id="selectUserById" resultMap="userResultMap">
        SELECT
            u.id AS id,
            u.username AS username,
            u.password AS password,
            a.id AS address_id,
            a.street AS street,
            a.city AS city,
            a.country AS country
        FROM users u
        LEFT JOIN addresses a ON u.address_id = a.id
        WHERE u.id = #{id}
    </select>

    <!-- 定义resultMap -->
    <resultMap id="userResultMap" type="User">
        <id property="id" column="id"/>
        <result property="username" column="username"/>
        <result property="password" column="password"/>
        <association property="address" javaType="Address">
            <id property="id" column="address_id"/>
            <result property="street" column="street"/>
            <result property="city" column="city"/>
            <result property="country" column="country"/>
        </association>
    </resultMap>

</mapper>

```



parameterType，指示参数类型

```java
public interface UserMapper {
    void insertUser(User user);
    void insertUserParams(@Param("username") String username, @Param("password") String password, @Param("email") String email);
}


<mapper namespace="com.example.UserMapper">

    <!-- 使用parameterType -->
    <insert id="insertUser" parameterType="User">
        INSERT INTO users (username, password, email)
        VALUES (#{username}, #{password}, #{email})
    </insert>

    <!-- 使用@Param注解 -->
    <insert id="insertUserParams">
        INSERT INTO users (username, password, email)
        VALUES (#{username}, #{password}, #{email})
    </insert>

</mapper>

```



sql、include：定义可复用的sql片段，引入sql片段

```xml
<sql id="userColumns">
  id, username, password
</sql>

<select id="selectUsers" resultType="User">
  SELECT <include refid="userColumns"/> FROM users
</select>

```



selectKey：标签用于在插入数据时获取数据库生成的主键或其他值；



动态标签：



trim、if：

```xml
<select id="selectUsers" resultType="User">
  SELECT * FROM users
  <trim prefix="WHERE" prefixOverrides="AND |OR ">
    <if test="username != null">
      AND username = #{username}
    </if>
    <if test="password != null">
      AND password = #{password}
    </if>
    <if test="email != null">
      AND email = #{email}
    </if>
  </trim>
</select>
```

在这个例子中，`<trim>` 元素被用来在 SQL 查询中添加 `WHERE` 子句，并且根据条件去除多余的 `AND` 或 `OR` 连接词。



where:

```xml
<select id="selectUsers" resultType="User">
  SELECT *
  FROM users
  <where>
    <if test="name != null">
      AND name = #{name}
    </if>
    <if test="age != null">
      AND age = #{age}
    </if>
  </where>
</select>

```



set：

```xml
<update id="updateUser" parameterType="User">
  UPDATE users
  <set>
    <if test="name != null">
      name = #{name},
    </if>
    <if test="age != null">
      age = #{age},
    </if>
    <if test="email != null">
      email = #{email},
    </if>
  </set>
  WHERE id = #{id}
</update>

```



choose：进行条件分支处理，类似于switch

```xml
<select id="getUsers" resultType="User">
  SELECT *
  FROM users
  <where>
    <choose>
      <when test="id != null">
        AND id = #{id}
      </when>
      <when test="name != null">
        AND name = #{name}
      </when>
      <otherwise>
        AND status = 'active'
      </otherwise>
    </choose>
  </where>
</select>

```



foreach：遍历集合

```xml
<select id="selectUsersByNumList" resultType="User" parameterType="java.util.List">
  SELECT *
  FROM users
  WHERE id IN
  <foreach item="id" collection="numList" open="(" separator="," close=")">
    #{id}
  </foreach>
</select>

```



bind：在SQL语句中创建和使用新的变量

```xml
<select id="selectUsersByAgeRange" resultType="User" parameterType="Map">
  <bind name="minAge" value="'20'"/>
  <bind name="maxAge" value="'30'"/>
  SELECT *
  FROM users
  WHERE age BETWEEN #{minAge} AND #{maxAge}
</select>

```



## 3.Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？

最佳实践中，通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 `Mapper` 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 `MappedStatement` 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 `Mapper` 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 `MappedStatement` ，举例：`com.mybatis3.mappers. StudentDao.findStudentById` ，可以唯一找到 namespace 为 `com.mybatis3.mappers. StudentDao` 下面 `id = findStudentById` 的 `MappedStatement` 。在 MyBatis 中，每一个 `<select>`、 `<insert>`、 `<update>`、 `<delete>` 标签，都会被解析为一个 `MappedStatement` 对象。



Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。

Dao 接口方法可以重载，但是需要满足以下条件：

1. 仅有一个无参方法和一个有参方法
2. 多个有参方法时，参数数量必须一致。且使用相同的 `@Param` ，或者使用 `param1` 这种



## 4.Mybatis是如何进行分页的？分页插件的原理是什么？

**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；

```xml
<!-- UserMapper.xml -->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.UserMapper">

    <select id="selectUsersWithPagination" resultType="User" parameterType="org.apache.ibatis.session.RowBounds">
        SELECT * FROM users
    </select>
    
</mapper>
```



```java
import org.apache.ibatis.session.RowBounds;
import java.util.List;

public interface UserMapper {
    List<User> selectUsersWithPagination(RowBounds rowBounds);
}
```



```java
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.RowBounds;

public class Example {
    public static void main(String[] args) {
        SqlSession sqlSession = ...; // 获取SqlSession对象

        // 创建RowBounds对象，指定偏移量和限制数量
        RowBounds rowBounds = new RowBounds(0, 10); // 从第一条记录开始，获取10条记录

        // 调用查询方法，并传入RowBounds对象
        List<User> users = sqlSession.getMapper(UserMapper.class).selectUsersWithPagination(rowBounds);
        
        // 处理查询结果
        for (User user : users) {
            System.out.println(user);
        }
    }
}

```



**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能；

```xml
<!-- UserMapper.xml -->
<select id="selectUsersWithPagination" resultType="User">
    SELECT * FROM users
    LIMIT #{offset}, #{limit}
</select>

```

**(3)** 也可以使用分页插件来完成物理分页。

分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。



## 5.简述MyBatis的插件运行原理，以及如何编写一个插件？

MyBatis 仅可以编写针对 `ParameterHandler`、 `ResultSetHandler`、 `StatementHandler`、 `Executor` 这 4 种接口的插件;MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 `InvocationHandler` 的 `invoke()` 方法，当然，只会拦截那些你指定需要拦截的方法。



1. 指定插件类型；
2. 实现Interceptor接口，重写方法；
3. JDK动态代理插件类型接口的接口方法，代理对象就是我们自定义的插件；

```java
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.plugin.*;

import java.sql.Connection;
import java.util.Properties;

@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
})
public class MyStatementInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        BoundSql boundSql = statementHandler.getBoundSql();

        // 获取原始的 SQL 语句
        String originalSql = boundSql.getSql();

        // 添加自定义的 SQL 片段
        String newSql = originalSql + " WHERE status = 'active'";

        // 修改原始的 SQL 语句为新的 SQL 语句
        BoundSql newBoundSql = new BoundSql(statementHandler.getConfiguration(), newSql, boundSql.getParameterMappings(), boundSql.getParameterObject());
        statementHandler.getClass().getDeclaredField("boundSql").setAccessible(true);
        statementHandler.getClass().getDeclaredField("boundSql").set(statementHandler, newBoundSql);

        // 继续执行原始的方法
        return invocation.proceed();
    }

    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {}
}

```

如何编写一个插件：

1. 实现 MyBatis 的 `Interceptor` 接口并复写 `intercept()` 方法，
2. 然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，
3. 记住，别忘了在配置文件中配置你编写的插件。



注：

ParameterHandler 为 SQL 语句设置参数，StatementHandler 创建并执行 SQL 语句，Executor 执行 SQL 语句并返回结果，ResultSetHandler 处理 SQL 查询结果集。



## 6.MyBatis执行批量插入，能返回数据库主键列表吗？

可以；

```java
import java.util.List;

public interface UserMapper {
    void batchInsert(List<User> userList);
}


<!-- UserMapper.xml -->
<mapper namespace="com.example.UserMapper">
    <insert id="batchInsert" useGeneratedKeys="true" keyProperty="id" parameterType="java.util.List">
        <foreach collection="list" item="user" separator=";">
            INSERT INTO user (name) VALUES (#{user.name})
        </foreach>
    </insert>
</mapper>

    
    
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserService {
    @Autowired
    private UserMapper userMapper;

    public List<Long> batchInsertAndGetIds(List<User> userList) {
        userMapper.batchInsert(userList);
        return userList.stream().map(User::getId).collect(Collectors.toList());
    }
}

```



## ----------------------------------------------

## 1.MyBatis动态sql是做什么的？能简述一下动态sql的执行原理吗？

动态SQL让我们可以在xml映射文件内，以标签的形式编写动态sql；



原理：使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。



## 2.Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？

有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。



映射形式：



第一种是使用 `<resultMap>` 标签，逐一定义列名和对象属性名之间的映射关系。

```xml
<resultMap id="userResultMap" type="User">
  <id property="id" column="id"/>
  <result property="name" column="name"/>
  <result property="age" column="age"/>
</resultMap>

<select id="selectUser" resultMap="userResultMap">
  SELECT id, name, age FROM users WHERE id = #{id}
</select>

```



第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。

```xml
<select id="selectUser" resultType="User">
  SELECT id AS id, T_NAME AS NaMe, age AS age FROM users WHERE id = #{id}
</select>

```



## 3.MyBatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？



## 4.MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？



## 5.MyBatis的xml映射文件中，不同的xml映射文件，id是否可以重复？



## 6.Mybatis如何执行批处理？



## 7.Mybatis都有哪些Executor执行器？它们之间的区别是什么？



## 8.Mybatis中如何指定使用哪一种Executor执行器？



## 9.Mybatis是否可以映射Enum枚举类？



## 10.Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能够定义在A标签的后面？



## 11.简述Mybatis的xml映射文件和Mybatis内部数据结构之间的映射关系？



## 12.为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？





# Sprng常见面试题

## 1.Resourece和Autowire的区别



## 2.Spring如何解决循环依赖



## 3.Spring的理解



## 4.Spring的bean生命周期





# SpringBoot常见面试题

## 1.说说SpringBoot自动装配的原理？

从三方面进行回答，

1. 什么是自动装配？
   1. 无需进行手动配置，SpringBoot通过@EnableAutoConfiguration注解，实现对jar包的MET-INF/Spring.factories的扫描，实现自动装配。
2. 如何实现自动装配的？如何实现按需加载？
   1. @SpringBootApplication中有三个注解，其中实现自动装配的核心注解是@EnableAutoConfiguration，导入了一个AutoConfigurationImportSelector类（实现了ImportSelector接口，重写selectorImports方法），扫描所有jar包下的MET-INF/Spring.factories的配置文件的全限定类名，进行按需加载到IOC容器中；
   2. 通过ConditionOnXXX来进行按需加载；
3. 如何实现一个Starter？
   1. 引入Spring-Boot-Starter依赖；
   2. 创建一个自动配置类；
   3. 创建MET-INF/Spring.factories配置文件中加上自动配置类的全限定类名；













# 简历可能被问问题

## 1.JVM内存模型

JVM由三部分组成：

1. 类加载子系统：可以根据指定的全限定类名加载类和接口
2. 执行引擎：执行那些在被加载入类的方法的指令
3. 运行时的数据区：当程序运行在jvm会存储许多内存并进行技术





程序计数器

Java虚拟机栈：局部变量表、操作数栈、动态链接、方法返回地址

本地方法栈（私有）：使用到的native方法



堆：存放对象实例，字符串常量池

方法区（逻辑区域）：元空间（运行时常量池（字面量、符号引用））、JIT编译后的代码、类的信息



## 2.堆分为哪些结构

老年代、新生代、元空间（直接内存）；

JVM的垃圾回收机制，

1. 对象首先在新生代的Eden区分配，当Eden区内存不足时，发起Minor GC；
2. GC期间发现Survivor空间也不足，就会提前将新生代的对象升为老年代；
3. 大对象（需要大量连续内存空间）直接进入老年代；长期存活的对象将进入老年代。



## 3.有垃圾回收器

1. Serial收集器
   1. 串行垃圾收集器，是单线程收集器，只会使用一条垃圾收集线程区完成垃圾收集工作，并且此时会暂停其他所有工作线程。
   2. 新生代采用标记-复制算法，老年代采用标记-整理算法
2. ParNew收集器
   1. 是Serial的多线程版本，是许多运行在Server模式下的虚拟机的首选。
3. Parallel Scavenge收集器
   1. 与ParNew类似，但是关注点在于提升CPU利用率，提供了很多参数提供给用户找到最合适的停顿时间或最大吞吐量，自适应调节策略，把内存管理优化交给虚拟机。
   2. JDK1.8默认收集器
6. CMS收集器
   1. 并发收集器，第一次实现了让垃圾回收线程与用户线程基本上同时工作
   2. 以获取最短停顿时间为目标的收集器，采用标记-清除算法
   3. 收集过程：
      1. 初始标记：暂停所有的其他线程，并记录下直接与root相连的对象；
      2. 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。
      3. 重新标记：为了修正并发标记阶段因为用户程序继续运行导致标记变动的对象的标记记录。
      4. 并发清除：开启用户线程，同时GC线程开始对未标记的区域做清扫。
   4. 缺点：导致大量内存碎片
7. G1收集器
   1. 满足GC停顿时间要求的同时，还具备高吞吐量性能特征；
   2. 并行与并发：充分利用多核CPU，将垃圾回收任务分配给多个 GC 线程，并行地执行垃圾收集操作，
   3. 让GC线程和用户线程并发执行。
   4. 分代收集：G1是一种分代垃圾收集器，但它不像传统的分代收集器（比如Serial、Parallel GC）那样严格区分年轻代和老年代。它将堆空间划分为多个大小相等的区域（Region），每个区域既可以是年轻代的一部分，也可以是老年代的一部分。
   5. 空间整合：G1整体上属于标记-整理，局部上属于标记-复制。
   6. 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。
   7. 过程：
      1. 初始标记
      2. 并发标记
      3. 最终标记
      4. 筛选回收
   8. G1在后台维护了一个优先列表，记录各个内存区域的垃圾回收价值，优先选择回收价值最大的内存。



## 4.详细谈谈G1收集器

答：

G1收集器是面向服务器的多核处理器和大内存垃圾收集器，在满足暂停时间的同时，还具备高吞吐量性能。

具体有几个特点：

- 并行与并发：垃圾回收线程并行执行，垃圾回收线程和用户线程并发执行；
- 分代：G1垃圾收集器把堆进行分区，并且后台维护一个优先级队列，按照优先级来对分区内存进行垃圾回收，每个分区都有新生代和老年代的概念。
- 空间整理算法：整体上看属于标记-整理，局部看属于复制。
- 可预测的停留：能够控制垃圾收集的停留时间不超过。

过程：

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收



## 5.聊聊你对JVM参数进行内存限制的详细做法

答：

OJ项目中的代码沙箱，需要对提交的代码内存进行限制，使用-Xmx256M进行最大内存限制。



## 6.聊聊Spring三级缓存解决循环依赖的问题

循环依赖：多个bean之间的相互依赖关系导致死循环；

Spring的三级缓存的底层其实就是，维护了三个map，一级缓存singletionObjects，二级缓存earlySingletionObjects，三级缓存singletionFactories，一级缓存存放初始化完成的bean，二级缓存存放初始化半成品的bean，三级缓存存放没有开始初始化的bean，

假设有两个beanA,beanB，相互依赖，

首先，beanA实例化完成，调用addSingletionFactory将ObjectFactory存入三级缓存，发现需要依赖注入beanB；

然后，实例化beanB，发现需要注入beanA，从三级缓存中取出beanA的ObjectFactory，调用getObject（调用getEarlyBeanRefer）获得原型bean或者代理bean，存入二级缓存，此时beanB初始化完成，存入一级缓存；

最后，beanA从一级缓存池中取出beanB，进行依赖注入成功，初始化完成，beanA存入一级缓存。





## 7.聊聊bean的生命周期

答：

bean的生命周期大方向上分为四步：实例化--属性赋值--初始化--使用--销毁，



初始化可以分为：

1. aware接口的实现情况
   1. beanNameAware
   2. classLoaderAware
   3. beanFactoryAware
2. 调用beanProcessors（List集合）的postProcessorBeforeInitialization方法，进行初始化之前的操作；
3. 初始化
   1. 是否实现了InitializingBean接口，调用afterPropertiesSet方法
   2. 是否有自定义的初始化方法实现（@PostConstruct）
4. 调用beanProcessors的postProcessorAfterInitialization方法，进行初始化之后的操作；
5. 注册销毁回调接口



销毁分为：

1. 是否实现DisposableBean接口，调用destory方法
2. 是否有自定义的销毁方法（@PreDestory）



```java
/**
 * 创建一个Bean实例，进行一系列的初始化操作。
 * 
 * @param beanName Bean的名称
 * @param mbd Bean的根定义
 * @param args 传给Bean构造函数的参数
 * @return 初始化后的Bean实例
 * @throws BeanCreationException 如果在创建或初始化Bean时发生错误
 */
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
    BeanWrapper instanceWrapper = null;
    // 检查是否是单例Bean，并尝试从缓存中获取已有的实例
    if (mbd.isSingleton()) {
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
    }

    // 如果缓存中没有，则创建一个新的Bean实例
    if (instanceWrapper == null) {
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);
    }

    Object bean = instanceWrapper.getWrappedInstance();
    Class<?> beanType = instanceWrapper.getWrappedClass();
    // 更新Bean定义的解析目标类型
    if (beanType != NullBean.class) {
        mbd.resolvedTargetType = beanType;
    }

    // 对合并后的Bean定义进行后处理
    synchronized(mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            } catch (Throwable var17) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", var17);
            }

            mbd.postProcessed = true;
        }
    }

    // 提前暴露单例Bean的实例，以解决潜在的循环依赖问题
    boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
    if (earlySingletonExposure) {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
        }

        this.addSingletonFactory(beanName, () -> {
            return this.getEarlyBeanReference(beanName, mbd, bean);
        });
    }

    Object exposedObject = bean;

    // 注入Bean的属性并初始化Bean
    try {
        this.populateBean(beanName, mbd, instanceWrapper);
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);
    } catch (Throwable var18) {
        // 如果初始化Bean的过程中抛出了BeanCreationException，并且是针对当前Bean的，则直接抛出
        if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
            throw (BeanCreationException)var18;
        }

        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
    }

    // 处理潜在的循环依赖问题
    if (earlySingletonExposure) {
        Object earlySingletonReference = this.getSingleton(beanName, false);
        if (earlySingletonReference != null) {
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            } else if (!this.allowRawInjectionDespiteWrapping && this.hasDependentBean(beanName)) {
                // 抛出循环依赖异常
                String[] dependentBeans = this.getDependentBeans(beanName);
                Set<String> actualDependentBeans = new LinkedHashSet(dependentBeans.length);
                String[] var12 = dependentBeans;
                int var13 = dependentBeans.length;

                for(int var14 = 0; var14 < var13; ++var14) {
                    String dependentBean = var12[var14];
                    if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }

                if (!actualDependentBeans.isEmpty()) {
                    throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.");
                }
            }
        }
    }

    // 注册Bean的销毁方法，如果必要的话
    try {
        this.registerDisposableBeanIfNecessary(beanName, bean, mbd);
        return exposedObject;
    } catch (BeanDefinitionValidationException var16) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", var16);
    }
}
```







```java

/**
 * 调用实现了特定接口的bean的方法，以注入相应的上下文信息。
 * 例如，如果bean实现了BeanNameAware接口，就会调用它的setBeanName方法，
 * 传入该bean的名称。此方法适用于实现了一系列Aware接口的bean，用于在bean实例化后注入额外的信息。
 *
 * @param beanName the name of the bean
 * @param bean     the bean instance to which context information will be injected
 */
private void invokeAwareMethods(String beanName, Object bean) {
    // 如果bean实现了Aware接口，则尝试注入上下文信息
    if (bean instanceof Aware) {
        // 如果bean实现了BeanNameAware接口，则注入bean名称
        if (bean instanceof BeanNameAware) {
            ((BeanNameAware)bean).setBeanName(beanName);
        }

        // 如果bean实现了BeanClassLoaderAware接口，则注入类加载器
        if (bean instanceof BeanClassLoaderAware) {
            ClassLoader bcl = this.getBeanClassLoader(); // 获取当前的类加载器
            if (bcl != null) {
                ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl);
            }
        }

        // 如果bean实现了BeanFactoryAware接口，则注入BeanFactory
        if (bean instanceof BeanFactoryAware) {
            ((BeanFactoryAware)bean).setBeanFactory(this);
        }
    }

}

```



```java

/**
 * 在Bean初始化之前应用所有的BeanPostProcessor处理器。
 * 
 * @param existingBean 待处理的Bean实例。
 * @param beanName Bean的名称。
 * @return 经过所有BeanPostProcessor处理器处理后的Bean实例。
 * @throws BeansException 如果处理过程中发生错误。
 */
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException {
    Object result = existingBean; // 初始化结果为传入的Bean实例

    Object current;
    // 遍历所有BeanPostProcessor处理器并应用它们
    for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) {
        BeanPostProcessor processor = (BeanPostProcessor)var4.next();
        // 应用当前BeanPostProcessor处理器
        current = processor.postProcessBeforeInitialization(result, beanName);
        // 如果处理器返回null，则停止遍历并返回当前结果
        if (current == null) {
            return result;
        }
    }

    return result; // 返回经过所有处理器处理后的Bean实例
}
```



```java
/**
 * 调用bean的初始化方法。
 * 此方法首先检查bean是否实现了InitializingBean接口，如果是，则调用afterPropertiesSet方法。
 * 接着，如果bean定义（RootBeanDefinition）存在，并且指定了自定义的初始化方法，那么将调用该自定义初始化方法。
 * 
 * @param beanName bean的名称。
 * @param bean 实际的bean实例。
 * @param mbd bean的根定义（RootBeanDefinition），可能为null。
 * @throws Throwable 如果在调用初始化方法时发生异常。
 */
protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable {
    // 检查bean是否为InitializingBean接口的实现，并且没有指定不调用afterPropertiesSet()的情况
    boolean isInitializingBean = bean instanceof InitializingBean;
    if (isInitializingBean && (mbd == null || !mbd.hasAnyExternallyManagedInitMethod("afterPropertiesSet"))) {
        // 如果日志级别允许，输出调用afterPropertiesSet()的trace信息
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
        }

        // 在存在安全管理员的情况下，使用特权执行afterPropertiesSet()
        if (System.getSecurityManager() != null) {
            try {
                AccessController.doPrivileged(() -> {
                    ((InitializingBean)bean).afterPropertiesSet();
                    return null;
                }, this.getAccessControlContext());
            } catch (PrivilegedActionException var6) {
                throw var6.getException();
            }
        } else {
            // 直接调用afterPropertiesSet()方法
            ((InitializingBean)bean).afterPropertiesSet();
        }
    }

    // 检查是否存在自定义的初始化方法，并且该方法不是afterPropertiesSet，并且没有被外部管理
    if (mbd != null && bean.getClass() != NullBean.class) {
        String initMethodName = mbd.getInitMethodName();
        if (StringUtils.hasLength(initMethodName) && (!isInitializingBean || !"afterPropertiesSet".equals(initMethodName)) && !mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {
            // 调用自定义的初始化方法
            this.invokeCustomInitMethod(beanName, bean, mbd);
        }
    }

}
```





```java
/**
 * 在Bean初始化后应用BeanPostProcessor处理器。
 * 遍历所有注册的BeanPostProcessor，并依次调用它们的postProcessAfterInitialization方法。
 * 如果某个处理器返回了非null的值，该值将作为下一个处理器的输入，或者作为最终结果返回。
 * 
 * @param existingBean 刚刚被初始化的Bean实例。
 * @param beanName Bean的名称。
 * @return 经过所有BeanPostProcessor处理后的Bean实例，可能是原始Bean，也可能是某个处理器返回的新实例。
 * @throws BeansException 如果在应用BeanPostProcessor时发生错误。
 */
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException {
    Object result = existingBean; // 初始化结果为传入的Bean实例。

    Object current;
    // 遍历所有BeanPostProcessor，并应用它们的postProcessAfterInitialization方法。
    for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) {
        BeanPostProcessor processor = (BeanPostProcessor)var4.next();
        current = processor.postProcessAfterInitialization(result, beanName);
        // 如果某个处理器返回null，则停止遍历并返回当前已处理的Bean实例。
        if (current == null) {
            return result;
        }
    }

    return result; // 返回经过所有处理器处理后的Bean实例。
}
```





```java
/**
 * 注册一个需要被销毁的bean，如果必要的话。
 * 这个方法主要用于处理非原型作用域的bean，且该bean声明了需要在销毁时执行的特定逻辑。
 * 对于单例bean，会直接注册为可销毁bean；对于其他作用域的bean，会向相应的作用域注册销毁回调。
 *
 * @param beanName   bean的名称。
 * @param bean       bean的实例。
 * @param mbd         bean的根bean定义，包含关于bean的各种配置信息。
 */
protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
    // 根据是否存在安全管理员，获取相应的访问控制上下文
    AccessControlContext acc = System.getSecurityManager() != null ? this.getAccessControlContext() : null;
    
    // 检查bean是否需要销毁且不是原型作用域的bean
    if (!mbd.isPrototype() && this.requiresDestruction(bean, mbd)) {
        // 处理单例作用域的bean
        if (mbd.isSingleton()) {
            this.registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, mbd, this.getBeanPostProcessorCache().destructionAware, acc));
        } else {
            // 获取bean所属的作用域
            Scope scope = (Scope)this.scopes.get(mbd.getScope());
            if (scope == null) {
                // 如果作用域未注册，则抛出异常
                throw new IllegalStateException("No Scope registered for scope name '" + mbd.getScope() + "'");
            }

            // 向作用域注册销毁回调
            scope.registerDestructionCallback(beanName, new DisposableBeanAdapter(bean, beanName, mbd, this.getBeanPostProcessorCache().destructionAware, acc));
        }
    }

}
```





```java

/**
 * 销毁bean及其资源的方法。
 * 此方法负责调用bean实现的特定销毁接口（如DisposableBean的destroy方法或实现了AutoCloseable的close方法），
 * 以及执行自定义的销毁方法（如果已指定）。在调用过程中，会捕获并记录任何异常。
 * 
 * 参数说明：
 * 无
 * 
 * 返回值：
 * 无
 */
public void destroy() {
    // 遍历并调用所有 DestructionAwareBeanPostProcessor 实现的 postProcessBeforeDestruction 方法
    if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {
        Iterator var1 = this.beanPostProcessors.iterator();

        while(var1.hasNext()) {
            DestructionAwareBeanPostProcessor processor = (DestructionAwareBeanPostProcessor)var1.next();
            processor.postProcessBeforeDestruction(this.bean, this.beanName);
        }
    }

    String msg;
    // 如果bean实现了DisposableBean接口，则调用其destroy方法
    if (this.invokeDisposableBean) {
        if (logger.isTraceEnabled()) {
            logger.trace("Invoking destroy() on bean with name '" + this.beanName + "'");
        }

        try {
            // 安全管理器检查，以决定是否需要以特权模式执行destroy方法
            if (System.getSecurityManager() != null) {
                AccessController.doPrivileged(() -> {
                    ((DisposableBean)this.bean).destroy();
                    return null;
                }, this.acc);
            } else {
                ((DisposableBean)this.bean).destroy();
            }
        } catch (Throwable var4) {
            msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'";
            // 异常记录，根据日志级别决定是否附带堆栈信息
            if (logger.isDebugEnabled()) {
                logger.warn(msg, var4);
            } else {
                logger.warn(msg + ": " + var4);
            }
        }
    }

    // 如果bean实现了AutoCloseable接口，则调用其close方法
    if (this.invokeAutoCloseable) {
        if (logger.isTraceEnabled()) {
            logger.trace("Invoking close() on bean with name '" + this.beanName + "'");
        }

        try {
            // 安全管理器检查，以决定是否需要以特权模式执行close方法
            if (System.getSecurityManager() != null) {
                AccessController.doPrivileged(() -> {
                    ((AutoCloseable)this.bean).close();
                    return null;
                }, this.acc);
            } else {
                ((AutoCloseable)this.bean).close();
            }
        } catch (Throwable var3) {
            msg = "Invocation of close method failed on bean with name '" + this.beanName + "'";
            // 异常记录，根据日志级别决定是否附带堆栈信息
            if (logger.isDebugEnabled()) {
                logger.warn(msg, var3);
            } else {
                logger.warn(msg + ": " + var3);
            }
        }
    } else if (this.destroyMethod != null) {
        // 执行自定义的销毁方法（如果已显式指定）
        this.invokeCustomDestroyMethod(this.destroyMethod);
    } else if (this.destroyMethodName != null) {
        // 尝试根据指定的销毁方法名称确定并执行销毁方法
        Method destroyMethod = this.determineDestroyMethod(this.destroyMethodName);
        if (destroyMethod != null) {
            this.invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(destroyMethod, this.bean.getClass()));
        }
    }
}

```



## 8.聊聊事务中的隔离性是如何保证的？MVCC

答：

通过MVCC和锁来实现；

MVCC是MYSQL中的多版本并发控制器，由三部分组成，

隐藏字段：最新操作数据行的事务id，上一条数据的undo log 地址；

undo log：回滚日志，事务每次操作数据行会将老数据存入undo log中，并形成数据链；

read view：读视图，每个事务开启都会创建一个读视图，从读视图里面得知本事务能访问的数据版本；

RC每次执行快照读的时候都会生成一个read view；



快照读：每次读取数据都会生成一个数据快照，读取的数据版本不能超过当前事务开启时的版本。

当前读：读取的数据是最新版本。update等操作



对于当前读，MVCC无法避免幻读的发生，此时配合Next Key Lock锁，对数据进行锁定，避免幻读的发生。



## 9.说说索引设计规范

1. 单表索引不要超过5个
2. 经常查询的字段建立索引
3. 经常修改的字段不要建立索引
4. 每张表都要有一个主键
5. 避免建立冗余索引和重复索引
7. 禁止使用全文索引



## 10.聊聊MYSQL优化的思路

答：

1. 数据库命名规范：
   1. 必须使用小写且用下划线分割；
   2. 不能使用关键字，如果使用了关键字要用单引号；
   3. 命名要见名知意；
2. 数据表设计规范：
   1. 表和字段要添加注释；
   2. 为字段选择合适的类型；
   3. 单表字段不要太多；
   4. 不要用字符串存储日期；
   5. 尽量把所有列设置为not null；
3. SQL优化
   1. 禁止使用select *；
   2. 使用insert语句要包含字段列表；
   3. 子查询换为join；
   4. join不要关联太多表；
   5. 不会有明显重复值时，使用union all 代替 union；
   6. 避免数据类型进行隐式转换；
4. 索引优化
   1. 选择合适字段创建索引；
   2. 限制索引数量；
   3. 使用联合索引；
   4. 比较索引冗余和重复；
   5. 删除长期未使用的索引；
   6. 避免索引失效
      1. 索引字段参与运算或函数；
      2. 违反最左匹配原则；
      3. 使用模糊查询%在最左边；
      4. 字段类型不同；
      5. or连接时，两边字段有一个不为索引；
      6. in的范围太大；
      7. 使用not in 和not exist；
      8. order by的多个字段排序顺序不同；



## 11.聊聊Redis的缓存雪崩、击穿、穿透的解决方案

答：

缓存穿透是访问的数据不存在时，大量请求经过Redis和MYSQL服务器，查询不到数据，导致服务器崩溃；

解决方案是：1.限制请求，对查询请求做判断，限制恶意访问不存在字段的请求；2.为不存在数据设置空值存在缓存中；3.使用布隆过滤器（使用位图，哈希运算，三个为1则存在，缺点：哈希碰撞，无法获取数据本身，难以删除）



缓存击穿是某个热点数据过期时，大量访问请求访问MYSQL数据库，导致MYSQL崩溃；

解决方案是：1.给热点数据设置永不过期；2.使用互斥锁，只有一个线程可以访问；



缓存雪崩是大量缓存数据同时过期，导致redis崩溃；

解决方案是：1.设置不同的过期时间；2.开启redis集群；



## 12.SpringCloud的五大组件

1. Eureka/Nacos
2. Ribbon
3. Feign
4. Hystrix/Sentinel：服务熔断
5. Gateway：网关



## 13.为什么使用Nacos，不使用Eureka？

因为Nacos支持配置中心；

Nacos集群默认采用AP（高可用）方式，当集群中存在非临时实例时，采用CP（强一致）模式；



## 14.你使用RabbitMQ解决了什么问题？

在API项目：

1. 登录和注册时的邮箱验证码的发送，第三方平台来监听消息，并发送邮件，业务代码松耦合；
2. 保证接口统计数据一致性，监听网关层面的接口统计接口是否调用成功，如果不成功，则进行接口统计回滚；使用手动确认机制，保证回滚成功，否则将消息重新放入队列。
3. 保证订单成功支付，使用Redis缓存分布式ID，解决消费端的消息幂等性问题；
4. 使用死信队列，解决订单超时问题；



## 15.Docker常用命令

docker ps ：查看所有运行中的容器；

docker ps -a：查看所有容器；

docker run imageId：运行一个容器；

docker start containerId：启动一个容器;

docker restart containterId：重启一个容器；

docker rmi imageId：删除一个镜像；

docker exec -it /bin/bash：交互式命令启动一个容器；



## 16.Linux常用命令

查询进程状态，可以使用 `ps` 命令。以下是一些常用的 `ps` 命令选项：

- `ps aux`：显示当前系统上所有进程的详细信息。
- `ps -ef`：显示所有进程的完整信息，包括命令行参数。
- `ps -e`：显示系统上所有正在运行的进程。
- `ps -f`：显示进程的详细信息，包括 UID、PID、PPID、C、STIME、TTY、TIME、CMD 等。
- `ps -u <用户名>`：显示指定用户的所有进程信息。
- `ps -p <PID>`：显示指定 PID 的进程信息。



top：监控系统的负载和查看进程的情况；

nestat -nlp | grep 端口号：查询端口号的进程





## 17.聊聊ArrayList的扩容机制

初始容量为10，扩容为1.5倍；

add方法，判断是否第一次添加元素，返回10和size+1的最大值，然后判断数组容量是否足够，不够则进行扩容；



grow方法，新容量扩容1.5倍，跟需要容量比较，如果小于需要容量，则新容量赋值为需要容量，进行数组复制；



## 18.OJ项目一定需要使用Spring Cloud架构吗？

不需要；

判断是否需要升级为微服务架构：

1. 项目复杂度增加：各个模块都需要独立扩展功能；
2. 提高系统的可靠性：微服务每个项目之间互不影响，某个服务挂了不会影响其他服务的运行；
3. 技术多样性需求：项目中的模块需要使用不同的技术栈；



OJ项目没有必要使用微服务，项目复杂度并不高，单体项目的完成度已然够用，如果按照业务来划为，并不会提高系统的可靠性，只要有一个项目挂了，其它项目的功能也随即失去了；



## 19.远程调用的时候，如果服务名更改了怎么办？

在application.yml中配置服务名，使用服务名的时候使用占位符的方式导入，服务名修改的话，只需要修改配置文件中的服务名，而不需要到代码中进行修改！！

















